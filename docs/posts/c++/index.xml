<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 顾起威的博客</title>
    <link>https://gqw.gitee.io/posts/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 顾起威的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn_ZH</language>
    <lastBuildDate>Wed, 18 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://gqw.gitee.io/posts/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;序列化和反序列化工具</title>
      <link>https://gqw.gitee.io/posts/c&#43;&#43;/serialization/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gqw.gitee.io/posts/c&#43;&#43;/serialization/</guid>
      <description>在开发时我们经常会遇到需要序列号和反序列化得操作。比如将程序配置导出下次打开再从配置中读取，通常你可以将信息保存成json、xml或ini格式，让后再解析出来。更常见的情形是我们通过网络发送和接收数据，也涉及到序列化和反序列化操作，当让你可以使用protobuf、msgpack等序列化库。但是如果你只是个简单程序，或者序列化和反序列化的业务不是很重，不想搞得那么复杂有什么简单的方法吗？
最直接的方法 直接按字节拷贝，见代码:
#include &amp;lt;string&amp;gt; bool encode(const std::string&amp;amp; s, int32_t a, int32_t b, int32_t c, std::string&amp;amp; buf) { int32_t d = static_cast&amp;lt;int32_t&amp;gt;(s.length()); if (buf.size() &amp;lt; (sizeof(int32_t) * 4 + d)) return false; std::size_t pos = 0; memcpy(buf.data() + pos, &amp;amp;a, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, &amp;amp;b, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, &amp;amp;c, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, &amp;amp;d, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, s.</description>
    </item>
    
    <item>
      <title>从HelloWold开始，深入浅出C&#43;&#43; 20 Coroutine TS</title>
      <link>https://gqw.gitee.io/posts/c&#43;&#43;/coroutine/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gqw.gitee.io/posts/c&#43;&#43;/coroutine/</guid>
      <description>缘起 前一阵子在查看asio库的时候看到在example目录中已经提供了coroutines_ts代码。很是好奇，便慢慢翻看代码，在感叹Coroutine给异步编程带来的优雅简洁的同时也带来了许多概念上的复杂和难以理解。由于C++ Coroutine还是一个比较新的概念，各个编译器厂商的实现还处于实验性的阶段[1] ，网上的资料少而松散。由此内心涌出一个念头想把自己的学习过程记录下来以期帮助后面学习的人。
从HelloWorld说起 再过两年这个世界的第一条HelloWorld代码就要有50年历史了[2] ，在此先提前蹭下热点，:)&amp;hellip;
#include &amp;lt;iostream&amp;gt;int main() { std::cout &amp;lt;&amp;lt; &amp;#34;hello, world&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 代码1这是一段平淡无奇的符合C++98标准的代码，你甚至可以用古董级编译器GCC 4.3都能编译通过[3]。但是我希望通过对这段代码的演化带领大家学习了解C++ 20中的Coroutine。
这段代码的作用很简单，打印一条&amp;quot;hello, world&amp;quot;，执行的也很快。但是这个世界并不总是那么简单美好，如果打印的逻辑非常耗时（特别是读取磁盘文件和进行网络请求时）而又需要频繁的调用就有些尴尬了，好了，我们改下代码来模拟这种情形：
#include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt;#include &amp;lt;chrono&amp;gt;using namespace std::chrono_literals; void remote_query() { // 假设这是个远程网络请求  std::this_thread::sleep_for(4s); std::cout &amp;lt;&amp;lt; &amp;#34;hello, world&amp;#34; &amp;lt;&amp;lt; std::endl; } int main() { for (;;) { remote_query(); } return 0; } 代码2改过后的代码不停的进行耗时的远程调用，每次远程调用需要消耗4秒的时间才能返回。可以看到，每次进行调用时程序都要暂停住（也就是卡住）而做不了其它事情。如果这是个带UI(用户界面)的程序，每次进行调用界面就要卡住，用户肯定是不能忍受的。
 注意
上面的代码由于使用了thread[4](C++ 11)和chrono_literals[5](C++ 14)，所以编译器需要支持C++ 14标准。
 多线程+Callback解决方案 为了解决上面的问题，我们对上面的代码进行如下改造：</description>
    </item>
    
  </channel>
</rss>
