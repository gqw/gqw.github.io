[{"categories":null,"contents":"markdown 图片加标注 \r\rHTTP下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 排列图片 \r\rHTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;BT\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/nD9GQ5mOpVv1ESR.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;BT下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 图片横排 HTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;div style=\u0026#34;display: flex;justify-content: space-around;\u0026#34;\u0026gt; \u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;bt\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/nD9GQ5mOpVv1ESR.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;BT下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/div\u0026gt;     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/notes/html/markdown-html/","summary":"markdown 图片加标注 \r\rHTTP下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 排列图片 \r\rHTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;BT\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.","tags":null,"title":"Html in markdown"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"问题 这两天在整理博客，一直使用GitHub和Gitee的Pages功能作为博客的静态托管站。但是遇到以下几个问题：\n 每次PUSH都要向两个网站分别提交，操作繁琐 域名问题， 博客使用的Hugo博客生成系统，根域名是在config.yaml配置的，导致最终的域名管理比较混乱。比如配置了github的域名，提交给gitee时忘记改，就会导致某些图片或内容访问不稳定。 Gitee发布比较麻烦，需要手动更新提交  解决方法   对于多次提交的问题，最初解决方法是使用以下命令：\n$ git remote set-url --add origin git@github.com:gqw/gqw.github.io.git $ git remote -v origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) origin git@github.com:gqw/gqw.github.io.git (push) 方法解决。添加过后每次提交都会同时往两个仓库提交。\n但是为了解决第二个问题，即不同域名问题，最终并未使用此方案。\n  解决不同域名问题，解决思路是通过git hook在提交和上次时在hook脚本里修改Hugo生成好的内容。\n 首先准备好远程url  $ git remote -v github_auto_change_domian git@github.com:gqw/gqw.github.io.git (fetch) github_auto_change_domian git@github.com:gqw/gqw.github.io.git (push) origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) 然后在仓库的.git/hooks目录中添加commit-msg文件，内容为：  commit_msg=$(cat $1) echo $commit_msg if [[ $commit_msg =~ \u0026#34;replace domain to github\u0026#34; ]]; then # 向github上传前会修改仓库内容，并做一次提交记录， # 这时不需要重新生成文档 echo \u0026#34;replace domain to github\u0026#34; else # 清空生成目录内容 rm -rfv ./docs/* # 重新生成 hugo # 复制一些固定内容 cp -v ./static/search_engine/* ./docs/ git add ./ fi exit 0 这样每次执行git commit时都会更新站点内容，保证每次提交内容都是最新的。\n在仓库的.git/hooks目录中添加pre-push文件，内容为：  remote=\u0026#34;$1\u0026#34; url=\u0026#34;$2\u0026#34; # 如果remote为 github_auto_change_domian 将跳过处理，否则会死循环， # 因为下面调用了git push 指令 if [ \u0026#34;$remote\u0026#34; == \u0026#34;origin\u0026#34; ];then # 修改域名 git ls-tree -r source --name-only | grep -E \u0026#34;docs/.*\\.html\u0026#34; | xargs sed -i \u0026#39;s/gqw\\.gitee/gqw\\.github/g\u0026#39; # 提交修改 git commit -a -s -m \u0026#34;replace domain to github\u0026#34; # 上传到giithub git push github_auto_change_domian echo \u0026#34;upload to github end\u0026#34; fi exit 0 至此上传和域名问题解决。\n  Gitee发布问题是通过网上别人提供的github action解决的。 在 .github/workflows 目录下添加任意*.yaml文件，内容如下：\nname: Deploy to Github Pages # run when a commit is pushed to \u0026#34;source\u0026#34; branch on: push: branches: - source jobs: deploy: runs-on: ubuntu-18.04 steps: - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: gqw # 注意在 Settings-\u0026gt;Secrets 配置 GITEE_PASSWORD gitee-password: ${{ secrets.GITEE_PASSWORD }} # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: gqw/gqw # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: source directory: docs https: true 此action其实只是通过python模拟登陆然后模拟用户提交更新请求。 具体使用请参考原文说明yanglbme/gitee-pages-action\n  总结 好了，遇到的问题现在都处理好了， 这样在每次commit是便会自动更新站点内容，push时会自动处理域名并向两个网站分别push, 最后还自动完成了gitee的站点更新。\n","date":"July 28, 2021","hero":"/posts/git/sync_github_gitee/imgs/github_gitee.jpg","permalink":"https://gqw.gitee.io/posts/git/sync_github_gitee/","summary":"问题 这两天在整理博客，一直使用GitHub和Gitee的Pages功能作为博客的静态托管站。但是遇到以下几个问题：\n 每次PUSH都要向两个网站分别提交，操作繁琐 域名问题， 博客使用的Hugo博客生成系统，根域名是在config.yaml配置的，导致最终的域名管理比较混乱。比如配置了github的域名，提交给gitee时忘记改，就会导致某些图片或内容访问不稳定。 Gitee发布比较麻烦，需要手动更新提交  解决方法   对于多次提交的问题，最初解决方法是使用以下命令：\n$ git remote set-url --add origin git@github.com:gqw/gqw.github.io.git $ git remote -v origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) origin git@github.com:gqw/gqw.github.io.git (push) 方法解决。添加过后每次提交都会同时往两个仓库提交。\n但是为了解决第二个问题，即不同域名问题，最终并未使用此方案。\n  解决不同域名问题，解决思路是通过git hook在提交和上次时在hook脚本里修改Hugo生成好的内容。\n 首先准备好远程url  $ git remote -v github_auto_change_domian git@github.com:gqw/gqw.github.io.git (fetch) github_auto_change_domian git@github.com:gqw/gqw.github.io.git (push) origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) 然后在仓库的.git/hooks目录中添加commit-msg文件，内容为：  commit_msg=$(cat $1) echo $commit_msg if [[ $commit_msg =~ \u0026#34;replace domain to github\u0026#34; ]]; then # 向github上传前会修改仓库内容，并做一次提交记录， # 这时不需要重新生成文档 echo \u0026#34;replace domain to github\u0026#34; else # 清空生成目录内容 rm -rfv .","tags":null,"title":"同步GitHub pages和 Gitee pages方法"},{"categories":null,"contents":"缘由与目标 随着计算机硬件的发展，游戏的玩法和画质也得到了飞速的发展。游戏内容越来越丰富，画面质量也越来越精细。这也导致了游戏的包体越来越大。PC端游戏基本上10GB起步，《战地》，《易水寒》等游戏基本已经达到100G体量。如此大的体量对于游戏发行方，是一个必须要考虑的问题。用于游戏分发的下载器我们必须考虑以下几个方面：\n1. 可访问， 这是下载器的首要前提，我们必须保证数据能够被联网的任意玩家可以访问到。\r2. 数据可靠，下载的资源必须是正确的内容。\r3. 速度，我们必须尽可能的保证玩家的下载速度。\r4. 稳定，需要能够稳定下载所需资源。\r5. 节省流量，虽然这是个可选项但是流量就意味着金钱，所以下载器还需要尽可能的节约流量。\r 通常的下载器使用的是Http方式下载，虽然能够保证可靠地数据访问，但是离高速稳定省流量还有较大差距，为了提高速度和稳定性我们通过使用CDN的方案有效解决。但是CDN解决不了节省流量的目标（实际上是增加流量成本的）， 简单的解决方法是使用压缩下载内容，目前项目中使用的下载器就是使用的这种方法。压缩数据的方法效果还是非常有效的，以某款为例，12GB的包可以压缩到7GB, 也就是可以节省40%的流量。\n是否可以有更有效的方法解决流量问题呢？很自然的想法是使用P2P加速技术。P2P是指 peer to peer, 即节点到节点数据传输，就是各个客户端之间数据传输。大家常见的P2P技术主要是BT下载技术，但是BT与我们前面使用的技术是由冲突的。我们先看下HTTP与BT的结构图进行简单的对比下：\nHTTP下载方式\r\rBT下载方式\r\r\r对比可知， HTTP是基于C/S架构的，客户机是严格依赖中心服务器的，BT无中心节点所有数据都是玩家之间传输。HTTP的好处是访问可控，只要客户机能连接到服务器就肯定能获得所需数据，但是服务器必须承担所有流量压力和流量费用。 BT的好处也是显而易见的，所有数据传输都是玩家之间的行为，甚至可以不需要部署服务器，服务器的压力和费用为零，但是BT却有可能违背我们前面所述下载的最基本要求——可访问，玩家节点的连接并不能像HTTP那样是可靠稳定的。\n有没有可能结合HTTP和BT技术，充分利用各自的优势并互相弥补对方的缺点呢？实现如下的结构：\nP2SP下载方式\r\r\r幸运的是答案为YES, 迅雷的P2SP技术就是基于上述思想实现的，说明技术方向是对的，不用再去怀疑和验证技术的可行性。但是需要注意的是，迅雷的P2S我们的需求是有差异的， 迅雷下载器P2S部分的S并不是自己的服务器（而是各个下载站点的服务器），所以它不用考虑这部分的流量压力和费用，而我们作为内容提供方流量和费用必须自己承担。所以迅雷并不关心用户数据是否压缩，但是对于我们内容提供商就必须要考虑通过前面压缩技术获得的40%的利益。\n看到这里你可能会想，压缩还不容易吗？直接用压缩软件把下载内容打包下上传到HTTP服务器不就行了吗？是的如果不考虑BT文件的分享率，这样做是解决了问题，但这意味着我们BT分享的内容也是个压缩包，因为我们业务是游戏启动器，也就是说我们不可能将用户下载的游戏安装包一直保留，举个例子，如果我们的游戏原始文件为100GB压缩后为60GB，如果按刚才的方案，用户下载60GB的安装包后，再解压为100GB的原始文件，也就是说必须占用用户160GB的磁盘空间，而这其中的60GB只是为了方便他人下载用的。\n如果在用户安装完游戏后再将安装包删除，那此用户通过BT分享的时间也就只有其下载+安装的时间了。如何解决这个矛盾呢？ 我们现在梳理下问题：\n 通过HTTP下载的内容需要时压缩的数据 通过BT分享的内容必须是原始的内容  通过分析我们可以发现看似不可调和矛盾其实是有解的。那就是需要在下载的时候将HTTP压缩数据原地解压。自此方案的的思路已经基本清晰，但还有一个需要考虑的问题，根据BT的协议标准，BT下载时是将所有数据拼成一个数据块，再将这个数据块进行切块下载的。这就导致一个问题，通常我们压缩数据是按照文件为单位进行压缩的，但是BT下载时是按照切块进行下载的，这会导致HTTP和BT下载内容对应不上，如下图：\nZIP格式\r\r\rBT格式\r\r\rBT的下载原理是根据上图将需要下载的内容先按照文件进行拼接再进行切片（Piece），建立多个下载通道，每个通道根据切片的状态选择下载并更新切片状态。在下载时BT将无视文件的概念，对于BT来说每次下载只是一片连续的数据块。这样如果HTTP按照文件从压缩包中提取数据，下载后将很难找到对应的BT文件中Piece的位移，也就无法更新下载Piece的状态。\n解决思路是，反过来我们在数据压缩时不再以文件为单位进行压缩，而是按照BT的Piece为单位创建压缩文件，并记录每个Piece在压缩文件中的位移。HTTP下载通道下载时先向BT模块申请需要下载的Piece，再根据Piece的位移从HTTP服务器下载相应内容，最后更新BT Piece状态。\n具体实施 准备阶段  创建种子文件（.torent） 根据种子文件中piece length创建压缩文件 修改种子文件添加peice的压缩信息，主要是每个piece压缩后大小和总压缩文件大小。可以根据piece压缩后大写算出每个piece的偏移量 上传压缩文件到CDN 修改种子文件添加CDN中压缩文件HTTP下载地址 上传种子文件到CDN  实际处理中1,2,3,5步骤可以通过修改torrent文件合并处理。\n下载阶段 修改BT下载器，根据torrent文件中的的压缩文件地址建立特殊下载通道，模拟BT请求下载块，根据BT文件中的压缩块大小计算Piece在压缩文件中的偏移，使用HTTP Range Requests标准下载对应的数据块，下载完后更新对应Piece状态。直至所有文件下载完成。\n相关工程 libtorrent\n","date":"July 27, 2021","hero":"/posts/net/p2p/imgs/hero.jpg","permalink":"https://gqw.gitee.io/posts/net/p2p/","summary":"缘由与目标 随着计算机硬件的发展，游戏的玩法和画质也得到了飞速的发展。游戏内容越来越丰富，画面质量也越来越精细。这也导致了游戏的包体越来越大。PC端游戏基本上10GB起步，《战地》，《易水寒》等游戏基本已经达到100G体量。如此大的体量对于游戏发行方，是一个必须要考虑的问题。用于游戏分发的下载器我们必须考虑以下几个方面：\n1. 可访问， 这是下载器的首要前提，我们必须保证数据能够被联网的任意玩家可以访问到。\r2. 数据可靠，下载的资源必须是正确的内容。\r3. 速度，我们必须尽可能的保证玩家的下载速度。\r4. 稳定，需要能够稳定下载所需资源。\r5. 节省流量，虽然这是个可选项但是流量就意味着金钱，所以下载器还需要尽可能的节约流量。\r 通常的下载器使用的是Http方式下载，虽然能够保证可靠地数据访问，但是离高速稳定省流量还有较大差距，为了提高速度和稳定性我们通过使用CDN的方案有效解决。但是CDN解决不了节省流量的目标（实际上是增加流量成本的）， 简单的解决方法是使用压缩下载内容，目前项目中使用的下载器就是使用的这种方法。压缩数据的方法效果还是非常有效的，以某款为例，12GB的包可以压缩到7GB, 也就是可以节省40%的流量。\n是否可以有更有效的方法解决流量问题呢？很自然的想法是使用P2P加速技术。P2P是指 peer to peer, 即节点到节点数据传输，就是各个客户端之间数据传输。大家常见的P2P技术主要是BT下载技术，但是BT与我们前面使用的技术是由冲突的。我们先看下HTTP与BT的结构图进行简单的对比下：\nHTTP下载方式\r\rBT下载方式\r\r\r对比可知， HTTP是基于C/S架构的，客户机是严格依赖中心服务器的，BT无中心节点所有数据都是玩家之间传输。HTTP的好处是访问可控，只要客户机能连接到服务器就肯定能获得所需数据，但是服务器必须承担所有流量压力和流量费用。 BT的好处也是显而易见的，所有数据传输都是玩家之间的行为，甚至可以不需要部署服务器，服务器的压力和费用为零，但是BT却有可能违背我们前面所述下载的最基本要求——可访问，玩家节点的连接并不能像HTTP那样是可靠稳定的。\n有没有可能结合HTTP和BT技术，充分利用各自的优势并互相弥补对方的缺点呢？实现如下的结构：\nP2SP下载方式\r\r\r幸运的是答案为YES, 迅雷的P2SP技术就是基于上述思想实现的，说明技术方向是对的，不用再去怀疑和验证技术的可行性。但是需要注意的是，迅雷的P2S我们的需求是有差异的， 迅雷下载器P2S部分的S并不是自己的服务器（而是各个下载站点的服务器），所以它不用考虑这部分的流量压力和费用，而我们作为内容提供方流量和费用必须自己承担。所以迅雷并不关心用户数据是否压缩，但是对于我们内容提供商就必须要考虑通过前面压缩技术获得的40%的利益。\n看到这里你可能会想，压缩还不容易吗？直接用压缩软件把下载内容打包下上传到HTTP服务器不就行了吗？是的如果不考虑BT文件的分享率，这样做是解决了问题，但这意味着我们BT分享的内容也是个压缩包，因为我们业务是游戏启动器，也就是说我们不可能将用户下载的游戏安装包一直保留，举个例子，如果我们的游戏原始文件为100GB压缩后为60GB，如果按刚才的方案，用户下载60GB的安装包后，再解压为100GB的原始文件，也就是说必须占用用户160GB的磁盘空间，而这其中的60GB只是为了方便他人下载用的。\n如果在用户安装完游戏后再将安装包删除，那此用户通过BT分享的时间也就只有其下载+安装的时间了。如何解决这个矛盾呢？ 我们现在梳理下问题：\n 通过HTTP下载的内容需要时压缩的数据 通过BT分享的内容必须是原始的内容  通过分析我们可以发现看似不可调和矛盾其实是有解的。那就是需要在下载的时候将HTTP压缩数据原地解压。自此方案的的思路已经基本清晰，但还有一个需要考虑的问题，根据BT的协议标准，BT下载时是将所有数据拼成一个数据块，再将这个数据块进行切块下载的。这就导致一个问题，通常我们压缩数据是按照文件为单位进行压缩的，但是BT下载时是按照切块进行下载的，这会导致HTTP和BT下载内容对应不上，如下图：\nZIP格式\r\r\rBT格式\r\r\rBT的下载原理是根据上图将需要下载的内容先按照文件进行拼接再进行切片（Piece），建立多个下载通道，每个通道根据切片的状态选择下载并更新切片状态。在下载时BT将无视文件的概念，对于BT来说每次下载只是一片连续的数据块。这样如果HTTP按照文件从压缩包中提取数据，下载后将很难找到对应的BT文件中Piece的位移，也就无法更新下载Piece的状态。\n解决思路是，反过来我们在数据压缩时不再以文件为单位进行压缩，而是按照BT的Piece为单位创建压缩文件，并记录每个Piece在压缩文件中的位移。HTTP下载通道下载时先向BT模块申请需要下载的Piece，再根据Piece的位移从HTTP服务器下载相应内容，最后更新BT Piece状态。\n具体实施 准备阶段  创建种子文件（.torent） 根据种子文件中piece length创建压缩文件 修改种子文件添加peice的压缩信息，主要是每个piece压缩后大小和总压缩文件大小。可以根据piece压缩后大写算出每个piece的偏移量 上传压缩文件到CDN 修改种子文件添加CDN中压缩文件HTTP下载地址 上传种子文件到CDN  实际处理中1,2,3,5步骤可以通过修改torrent文件合并处理。\n下载阶段 修改BT下载器，根据torrent文件中的的压缩文件地址建立特殊下载通道，模拟BT请求下载块，根据BT文件中的压缩块大小计算Piece在压缩文件中的偏移，使用HTTP Range Requests标准下载对应的数据块，下载完后更新对应Piece状态。直至所有文件下载完成。","tags":null,"title":"一种简单可行的P2SP实践方案"},{"categories":null,"contents":"tcprt 介绍  产品发布后有玩家反映客户端（Windows系统）无法连接服务器， 使用ping.exe、tracert.exe工具检查均未发现有异常情况，但是telnet却无法连接。最后发现发现国内某些运营商网络在对icmp和tcp协议的路由选择上不一致导致。最后运维人员希望能够收集出错时的路由信息。 我们知道在Linux系统上实现很简单系统自带的traceroute工具自带tcp协议的探测，实现起来比较简单。但是客户端产品大多是Windows系统的，自带的tracert.exe只有icmp探测类型。下图是分别使用ICMP和TCPtracerouter的对比，图中可以看到明显的不同路由路径。 目标   实现类似于linux的traceroute -T方法  原理与实现  tracerouter原理  为了理解tracerouter原理，我们先来看下IP的协议头： 这里面有个8比特的Time To Live (TTL)字段，它代表是报文的存活时间，这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份ICMP报文被发回报文发送端说明其发送的报文已被丢弃。这也是traceroute的核心原理。 什么意思呢？我们看下下面的图： 这里表示的是192.168.1.2这台客户机访问192.168.5.32的路由图，报文首先在客户机（1.2）这台机器被创建出来并设置TTL字段为128, 然后经过若干路由接力传递最终到达目标服务器，在接力过程中没遇到一个路由中转，路由器均会将TTL值减一。再看这张图： 这次我们在客户机组装报文时将TTL设置的比较小只有3，这样在报文到达第一个路由路时路由检查报文中TTL的值发现TTL大于1于是修改报文将TTL减1继续转发给下一个路由，第二个路由采用同样的方法修改TTL后继续发给第三个路由，第三个路由受到报文时同样检查TTL值，发现TTL值已经为1，意识到自己已经是最后一跳不能再继续转发了，所以直接向源主机发送类型为11的ICMP报文告诉源主机报文发送失败（当然返回的报文也需要若干路由跳转，图中返回的虚箭头指示表达报文最终到达源主机）。\ntraceroute为了探测每个路由的地址，循环递增报文的TTL值，当TTL等于1时第一个路由便返回ICMP报文，源机器便可根据其IP头获得路由地址，当TTL等于2时可以得到第二个路由地址，依次循环下去直到到达目标机器。\n实现  tracert在Windows下只有基于ICMP协议的实现。Linux下倒是有TCP版本的实现，\ntraceroute -T www.baidu.com 80 既然如此那就看看源码，借鉴下别人是怎么实现的。Linux下traceroute[3]的思路比较直接，使用原始套接字（SOCK_RAW）向目的主机发送tcp连接, 并递增请求包的TTL值，再用recvmsg中flags设置MSG_ERRQUEUE选项来获取连接信息。\n但是在Windows系统下就没有那么幸运了。系统为了安全考虑（主要怕原始套接字被滥用）禁止了以下行为[1]：\n  TCP data cannot be sent over raw sockets.\n  A call to the bind function with a raw socket for the IPPROTO_TCP protocol is not allowed.\n  而且recvmsg也没有MSG_ERRQUEUE可以使用。所以直接照搬Linux下traceroute的想法没法设施。\n既然系统把路堵住了，有没有办法绕开去呢？其实是有的，在微软的文档中提到[1]：\n On Windows Server 2003 and earlier, a Transport Driver Interface (TDI) provider and a Winsock helper DLL can be written to support the network protocol. The network protocol would then be added to the Winsock catalog as a supported protocol. This allows multiple applications to open sockets for this specific protocol and the device driver can keep track of which socket receives specific packets and errors.\n 也就是需要你自己开发个驱动。好在有人已经实现了这样的功能，winpcap便是这样的网络库，也有人基于此开发了Windows下基于tcp协议的traceroute[2]。但是为了这么一个简单的功能开发让用户安装如此危险的驱动程序，对用户来说是十分不友好的（winpcap静默安装是收费功能）。\n还有其它方法吗？让我们回过头来仔细分析下思路。我们想要探测只需要每次发送的网络包中的ttl逐渐增大便可以了。系统限制了我们直接组装TCP网络包的能力，我们能否利用现有的资源呢？\n 我们正常建立TCP连接总还是可以的，只是我们有手段修改其TTL的值吗？ 幸运的是可以的。(Lucky + 1) 发送的数据有了，接收有吗？TTL值为0时路由会返回ICMP包吗？ 同自己组装的效果一样，也是有的。(Lucky + 1) 我们没有MSG_ERRQUEUE，可以获得响应内容吗？ 回答是Yes。 (Lucky + 1)  有了上面的3个幸运值，我们就可以实现我们的目的了，思路如下：\n 建立正常的TCP套接字进行connect连接，不过调用前通过修改socket选项修改TTL值。 另外再建立个原始套接字，监听所有响应。 收到任何响应关闭TCP套接字。  实现细节参考代码。\n下面说下实现时的一些注意点：\n 修改TTL方法： setsockopt (tcp_sk, IPPROTO_IP, IP_TTL, (char*)\u0026amp;ttl, sizeof (ttl))  设置连接socket为非阻塞模式，这样connect后可以立即监听网络响应。 因为是并发请求所以需要在connect之前bind一下，这样可以在探测结束前一直占用一个本地端口号，后面也可以根据这个端口进行信息匹配。 监听的原始套接字通过下面代码创建： socket(AF_INET, SOCK_RAW, IPPROTO_IP)  原始套接字需要打开 SIO_RCVALL 选项，这样才能收到所有网络包，包括connect连接成功后的syn+ack包。 打开 SIO_RCVALL 选项需要先进行bind操作才可以，不然会报10022错误。 因为打开了 SIO_RCVALL 所以每个探测线程会收到bind地址的所有网络包，所以要根据协议头进行过滤和区分。前面占用的本地端口是探测线程的一个重要依据。  优势与不足  优势  并发探测，探测时间与ttl值无关，速度相对于windows系统自带命令快N倍。 代码精简（不到500行代码），不依赖任何第三方库。  缺点  由于使用原始套接字（SOCK_RAW）代码执行需要管理员权限。 由于并发请求，无法做到及时停止探测，会造成很多无用的探测。  使用  git clone https://github.com/gqw/tcprt.git cd tcprt mkdir build cd build cmake .. ./tcprt.exe 180.101.49.11 80 30\r计划内容   支持ipv6 支持域名解析  参考文献 [1] TCP/IP Raw Sockets[EB/OL]. https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2\n[2] tracetcp[EB/OL]. https://github.com/0xcafed00d/tracetcp\n[3] traceroute[EB/OL]. http://ftp.oregonstate.edu/.2/lfs-website/blfs/view/svn/basicnet/traceroute.html\n","date":"December 29, 2020","hero":"/posts/net/tcptrace/images/forest.jpg","permalink":"https://gqw.gitee.io/posts/net/tcptrace/","summary":"tcprt 介绍  产品发布后有玩家反映客户端（Windows系统）无法连接服务器， 使用ping.exe、tracert.exe工具检查均未发现有异常情况，但是telnet却无法连接。最后发现发现国内某些运营商网络在对icmp和tcp协议的路由选择上不一致导致。最后运维人员希望能够收集出错时的路由信息。 我们知道在Linux系统上实现很简单系统自带的traceroute工具自带tcp协议的探测，实现起来比较简单。但是客户端产品大多是Windows系统的，自带的tracert.exe只有icmp探测类型。下图是分别使用ICMP和TCPtracerouter的对比，图中可以看到明显的不同路由路径。 目标   实现类似于linux的traceroute -T方法  原理与实现  tracerouter原理  为了理解tracerouter原理，我们先来看下IP的协议头： 这里面有个8比特的Time To Live (TTL)字段，它代表是报文的存活时间，这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份ICMP报文被发回报文发送端说明其发送的报文已被丢弃。这也是traceroute的核心原理。 什么意思呢？我们看下下面的图： 这里表示的是192.168.1.2这台客户机访问192.168.5.32的路由图，报文首先在客户机（1.2）这台机器被创建出来并设置TTL字段为128, 然后经过若干路由接力传递最终到达目标服务器，在接力过程中没遇到一个路由中转，路由器均会将TTL值减一。再看这张图： 这次我们在客户机组装报文时将TTL设置的比较小只有3，这样在报文到达第一个路由路时路由检查报文中TTL的值发现TTL大于1于是修改报文将TTL减1继续转发给下一个路由，第二个路由采用同样的方法修改TTL后继续发给第三个路由，第三个路由受到报文时同样检查TTL值，发现TTL值已经为1，意识到自己已经是最后一跳不能再继续转发了，所以直接向源主机发送类型为11的ICMP报文告诉源主机报文发送失败（当然返回的报文也需要若干路由跳转，图中返回的虚箭头指示表达报文最终到达源主机）。\ntraceroute为了探测每个路由的地址，循环递增报文的TTL值，当TTL等于1时第一个路由便返回ICMP报文，源机器便可根据其IP头获得路由地址，当TTL等于2时可以得到第二个路由地址，依次循环下去直到到达目标机器。\n实现  tracert在Windows下只有基于ICMP协议的实现。Linux下倒是有TCP版本的实现，\ntraceroute -T www.baidu.com 80 既然如此那就看看源码，借鉴下别人是怎么实现的。Linux下traceroute[3]的思路比较直接，使用原始套接字（SOCK_RAW）向目的主机发送tcp连接, 并递增请求包的TTL值，再用recvmsg中flags设置MSG_ERRQUEUE选项来获取连接信息。\n但是在Windows系统下就没有那么幸运了。系统为了安全考虑（主要怕原始套接字被滥用）禁止了以下行为[1]：\n  TCP data cannot be sent over raw sockets.\n  A call to the bind function with a raw socket for the IPPROTO_TCP protocol is not allowed.\n  而且recvmsg也没有MSG_ERRQUEUE可以使用。所以直接照搬Linux下traceroute的想法没法设施。\n既然系统把路堵住了，有没有办法绕开去呢？其实是有的，在微软的文档中提到[1]：\n On Windows Server 2003 and earlier, a Transport Driver Interface (TDI) provider and a Winsock helper DLL can be written to support the network protocol.","tags":null,"title":"tcprt"},{"categories":null,"contents":"在开发时我们经常会遇到需要序列号和反序列化得操作。比如将程序配置导出下次打开再从配置中读取，通常你可以将信息保存成json、xml或ini格式，让后再解析出来。更常见的情形是我们通过网络发送和接收数据，也涉及到序列化和反序列化操作，当让你可以使用protobuf、msgpack等序列化库。但是如果你只是个简单程序，或者序列化和反序列化的业务不是很重，不想搞得那么复杂有什么简单的方法吗？\n最直接的方法 直接按字节拷贝，见代码:\n#include \u0026lt;string\u0026gt; bool encode(const std::string\u0026amp; s, int32_t a, int32_t b, int32_t c, std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); if (buf.size() \u0026lt; (sizeof(int32_t) * 4 + d)) return false; std::size_t pos = 0; memcpy(buf.data() + pos, \u0026amp;a, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;b, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;c, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;d, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, s.data(), d); return true; } bool decode(const std::string\u0026amp; buf, int32_t\u0026amp; a, int32_t\u0026amp; b, int32_t\u0026amp; c, std::string\u0026amp; out) { if (buf.size() \u0026lt; (sizeof(int32_t) * 4)) return false; std::size_t pos = 0; memcpy(\u0026amp;a, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(\u0026amp;b, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(\u0026amp;c, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); int32_t d = 0; memcpy(\u0026amp;d, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); out = std::string(buf.data() + pos, d); return true; } int main() { std::string buf; buf.resize(1024); encode(\u0026#34;test\u0026#34;, 1, 2, 3, buf); std::string out; int a = 0, b = 0, c =0; decode(buf, a, b, c, out); return 0; } 或者简单封装下：\nstruct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { ... } bool decode(const std::string\u0026amp; buf) { ... } }; TestData in{ 1, 2, 3, \u0026#34;test\u0026#34; }; std::string buf; buf.resize(1024); in.encode(buf); TestData out; out.decode(buf); 使用stringstream 可以看到上面的代码还是比较繁琐的，不仅需要手动计算字符索引位置，还要直接使用memcpy函数。对于这个问题c++的stringstream可以简化不少代码：\nstruct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); std::ostringstream ss; ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; buf = ss.str(); return ss.good(); } bool decode(const std::string\u0026amp; buf) { std::istringstream ss(buf); int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; 可以明显的看出代码比前面的要简洁优雅多了，但是这里面却有个比较严重的问题，无论是encode还是decode都需要构建stringstream，而stringstream会在内部构建一个新的streambuf对象，无论是输入还是输出都需要一次拷贝操作。\n我们还有strstream struct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); std::ostrstream ss(buf.data(), buf.length()); ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; return ss.good(); } bool decode(const std::string\u0026amp; buf) { std::istrstream ss((char*)buf.data(), buf.length()); ss.seekp(buf.length()); // 设置写入位置（写入位置\u0026gt;读取位置才代表有数据可读）  int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; stringstream使用的人比较多，但是知道strstream的就少的多了。strstream可以使用已有的内存做rdbuf, 但是很不幸的是这么好用的工具竟然被c++标准给废弃了[1][2]。\n最后大招，自己造轮子 struct serialization_streambuf : public std::streambuf { serialization_streambuf(char* s, std::size_t n) { setp(s, s, s + n); // set write buffer pointer \tsetg(s, s, s + n); // set read buffer pointer \t} }; struct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); serialization_streambuf osrb(buf.data(), buf.length()); std::ostream ss(\u0026amp;osrb); ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; return ss.good(); } bool decode(const std::string\u0026amp; buf) { serialization_streambuf osrb((char*)buf.data(), buf.length()); std::istream ss(\u0026amp;osrb); int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; 可以看到，其实也很简单。就是模仿strstream为iostream构建streambuf就行了。这样不仅享受到了iostream类给我们提供的便利，也克服了stringstream需要内存拷贝的缺陷。\n参考引用 [1] std::strstream[EB/OL]. https://en.cppreference.com/w/cpp/io/strstream\n[2] Why was std::strstream deprecated?[EB/OL]. https://stackoverflow.com/questions/2820221/why-was-stdstrstream-deprecated\n","date":"November 18, 2020","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/posts/c++/serialization/","summary":"在开发时我们经常会遇到需要序列号和反序列化得操作。比如将程序配置导出下次打开再从配置中读取，通常你可以将信息保存成json、xml或ini格式，让后再解析出来。更常见的情形是我们通过网络发送和接收数据，也涉及到序列化和反序列化操作，当让你可以使用protobuf、msgpack等序列化库。但是如果你只是个简单程序，或者序列化和反序列化的业务不是很重，不想搞得那么复杂有什么简单的方法吗？\n最直接的方法 直接按字节拷贝，见代码:\n#include \u0026lt;string\u0026gt; bool encode(const std::string\u0026amp; s, int32_t a, int32_t b, int32_t c, std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); if (buf.size() \u0026lt; (sizeof(int32_t) * 4 + d)) return false; std::size_t pos = 0; memcpy(buf.data() + pos, \u0026amp;a, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;b, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;c, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;d, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, s.","tags":null,"title":"C++序列化和反序列化工具"},{"categories":null,"contents":"\r\r缘起 前一阵子在查看asio库的时候看到在example目录中已经提供了coroutines_ts代码。很是好奇，便慢慢翻看代码，在感叹Coroutine给异步编程带来的优雅简洁的同时也带来了许多概念上的复杂和难以理解。由于C++ Coroutine还是一个比较新的概念，各个编译器厂商的实现还处于实验性的阶段[1] ，网上的资料少而松散。由此内心涌出一个念头想把自己的学习过程记录下来以期帮助后面学习的人。\n从HelloWorld说起 再过两年这个世界的第一条HelloWorld代码就要有50年历史了[2] ，在此先提前蹭下热点，:)\u0026hellip;\n#include \u0026lt;iostream\u0026gt;int main() { std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码1\r这是一段平淡无奇的符合C++98标准的代码，你甚至可以用古董级编译器GCC 4.3都能编译通过[3]。但是我希望通过对这段代码的演化带领大家学习了解C++ 20中的Coroutine。\n这段代码的作用很简单，打印一条\u0026quot;hello, world\u0026quot;，执行的也很快。但是这个世界并不总是那么简单美好，如果打印的逻辑非常耗时（特别是读取磁盘文件和进行网络请求时）而又需要频繁的调用就有些尴尬了，好了，我们改下代码来模拟这种情形：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; void remote_query() { // 假设这是个远程网络请求  std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { for (;;) { remote_query(); } return 0; } 代码2\r改过后的代码不停的进行耗时的远程调用，每次远程调用需要消耗4秒的时间才能返回。可以看到，每次进行调用时程序都要暂停住（也就是卡住）而做不了其它事情。如果这是个带UI(用户界面)的程序，每次进行调用界面就要卡住，用户肯定是不能忍受的。\n 注意\n上面的代码由于使用了thread[4](C++ 11)和chrono_literals[5](C++ 14)，所以编译器需要支持C++ 14标准。\n 多线程+Callback解决方案 为了解决上面的问题，我们对上面的代码进行如下改造：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; #include \u0026lt;string\u0026gt;#include \u0026lt;future\u0026gt; void remote_query(uint32_t query_index, std::function\u0026lt;void(uint32_t)\u0026gt;\u0026amp;\u0026amp; callback) { std::thread t( [query_index, callback = std::move(callback)]() { std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; std::to_string(query_index) + \u0026#34; times query: Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; callback(query_index); }); t.detach(); } void remote_callback(uint32_t query_index) { remote_query(++query_index, remote_callback); } int main() { remote_query(1, remote_callback); while (true) { std::this_thread::sleep_for(1s); std::cout \u0026lt;\u0026lt; \u0026#34;main thread doing other things...\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 代码3\r打印结果：\nmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r1 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r2 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\r是的，我们可以通过多线程解决卡顿的问题，但这是个好的方案吗？不说线程的开销（其实创建和销毁一个线程无论从时间还是空间上来说都是非常大的开销），单从代码的组织来看也足够让人头疼的了。上面的代码只是循环调用同样的远程方法，如果remote_callback调用remote_query1(另一个远程调用)，remote_query1回调中再调用remote_query2\u0026hellip;如此下去代码逻辑将会非常恐怖。如果不能明白我说的是什么意思，callback hell 了解下:)， 为什么说是恐怖，因为这完全不符合人类的思维逻辑。人类喜欢的代码是有条不紊的按步执行，而不是在各个回调中跳来跳去。最好就像前面的同步代码，一个请求走完再执行下一个请求。\n主角登场 有没有什么方法解决这种复杂性呢？有的，技术牛人们早已发现这个问题并且给出了设计模型，有类似于libevent的Reactor模式[6]，也有asio的Proactor模式[7]。但Reactor，Proactor模式的核心思想都是通过事先注册回调函数，收到消息再根据消息内容查找并执行回调，有效的将层层包裹的回调给摊平以达到降低回调函数管理的复杂度。但是无论Reactor还是Proactor调用逻辑和回调逻辑还是被硬生生的给割裂开了。如何弥合这里的割裂呢？这就需要请出我们今天的主角Corouter了，还是先看代码吧：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; #include \u0026lt;string\u0026gt;#include \u0026lt;future\u0026gt; std::future\u0026lt;std::string\u0026gt; remote_query(uint32_t query_index) { return std::async([query_index]() { std::this_thread::sleep_for(4s); return std::to_string(query_index) + \u0026#34; times query: Hello, world!\u0026#34;; }); } std::future\u0026lt;void\u0026gt; remote_query_all() { uint32_t query_index = 0; for (;;) { std::string ret = co_await remote_query(++query_index); std::cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; std::endl; } } int main() { remote_query_all(); while (true) { std::this_thread::sleep_for(1s); std::cout \u0026lt;\u0026lt; \u0026#34;main thread doing other things...\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 代码4\r打印结果：\nmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r1 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r2 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r看到了吗？打印结果还是一样的，但是回调没有了, 从代码上看函数remote_query_all的逻辑也是在一个for循环中按步执行。好了，讲到这里只是希望你能直观的体会到使用Coroutine的作用和好处，但是你心中一定会有n个问号。\n 这不科学呀，remote_query返回值不是std::future\u0026lt;std::string\u0026gt;吗？ 怎么直接赋值给std::string了？ co_await 又是什么鬼？ remote_query 是个异步调用, 返回的ret直接用会不会崩溃？ \u0026hellip;  请少安毋躁， 暂时按下心中的疑惑，因为这边的水很深，坑很大，不是三言两语能够解释的清楚的。我会尽量努力在后面的内容中消除你心中的困惑。\n先从定义说起 翻开cppreference看看协程的定义[8]：\n协程是能暂停执行以在之后恢复的函数。协程是无栈的：它们通过返回到调用方暂停执行，并且从栈分离存储恢复所要求的数据。这允许编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O），还支持对惰性计算的无限序列上的算法及其他用途。\r若函数的定义做下列任何内容之一，则它是协程：\r. 用 co_await 运算符暂停执行，直至恢复\r. 用关键词 co_yield 暂停执行并返回一个值\r. 用关键词 co_return 完成执行并返回一个值\r读完之后似乎还是什么都不知道，好吧，现在我们试着逐句翻译成“白话文”。\n  协程是能暂停执行以在之后恢复的函数。\n这里的协程就是前面说的Coroutine, 这句说出了协程的本质。首先它是一个函数，然后这个函数与普通函数的区别是能够“暂停”和“恢复”执行代码。所以协程最关键的点是“暂停”和“恢复”。用一段代码说明下：\n void foo() {\rcode1;\rcode2;\rcode3;\r}\rint main() {\rfoo();\rreturn 0;\r}\r代码5\r这是一段普通的代码，代码从main函数开始，先调用foo函数，接着依次调用code1、code2、code3，然后返回main函数，最后执行return 0。这种执行顺序是我们见到的最常见的顺序，代码逐行执行，按部就班符合我们的预期。但是如果是协程，代码就可以在执行完code1后立马返回到main函数，在适当时候再返回foo执行code1后面的代码code2——这就是前面所谓的“暂停”和“恢复”。其实仔细想想所谓协程也只是计算机执行顺序的一种规范，有点类似goto指令，都是用于改变常规的代码执行顺序，只是这些规范我们用的比较少见而已。其实翻阅维基百科的“协程”页面[9]，你会发现其实协程历史并不短，起码已经超过半个世纪了。但是直到最近几年才开始火热是有原因的，就像goto语句一样，过多的自由有时也是一种灾难（代码逻辑混乱，难以维护）。但是随着计算机硬件的发展（多核多线程）和一些成熟的案例（如腾讯的libco[10]和golang[11]）出现，让人们认识到了协程的优势和闪光点。\n  协程是无栈的。\n“无栈” 两个字隐藏了太多的概念，对于一个完全没有接触过协程的人来说这个概念太含糊和陌生了。这里的“无栈”是相对于协程的另一种实现方式“有栈”协程而言的。在介绍这两个概念前先看下普通函数调用堆栈。函数堆栈非正式的理解就是函数调用时申请的用于存放参数和临时变量的内存块，按照后进先出（LIFO, Last In First Out）的规则分配内存，因为只有push和pop两种操作所以比较简单和快捷，由编译器自动管理其分配内存的生命周期。 在https://godbolt.org/里写下测试代码得到如下汇编指令：\n\r图1 函数调用汇编分析源码\r\r经过简单整理可得到堆栈的使用情况如下图所示：\n\r图2 函数调用堆栈变化\r\r 注意\n上面的代码是使用x64位的msvc编译的，和经常见到x86版本相比64位版本的更加简洁易懂，少了“基址指针寄存器”的概念所以省去了保存和恢复基址指针的操作。这里也没有常规的push和pop操作，而是直接通过sub和add相应的地址偏移获得相同的效果。\n 通过上面的分析我们可以看到，每次进行函数调用我们都需要为被调用的函数分配栈空间，用以保存调用参数和局部变量。为了实现协程，我们必须要实现前面说的“暂停”和“恢复”特性。有栈协程为了实现这两个特性做法是想办法在暂停后保存这些参数、变量以及相关的寄存器，在需要恢复调用前再将保存的信息恢复。在Linux中可以调用ucontext族函数getcontext、setcontext等实现[12]；Boost库也有类似的实现Boost.Context[13]；甚至可以自己通过汇编实现，例如微信的libco[14]。\n无栈协程不需要此过程。 在《使用 C 语言实现协程》[15]文章作者详细介绍了一种利用达夫设备[16]原理使用C语言实现协程的方法。由于原理比较简单在此粗略的介绍下其核心代码：\nint function(void) { static int i, state = 0; switch (state) { case 0: // 函数开始执行  for (i = 0; i \u0026lt; 10; i++) { state = 1; // 我们会回到 \u0026#34;case 1\u0026#34; 的地方  return i; case 1:; // 从上一次返回之后的地方开始执行  } } return i; } 代码6\r这段奇怪的代码之所以能够正确执行是因为C语言标准规定：“在switch控制语句内，条件标号（case）可以出现在任意子语句之前，充作其前缀” [[16]](#ref_16)。现在分析下代码：\r第1次调用function()时, state值为0，所以执行case 0，然后执行for循环体，i赋0， state赋1(相当于保存状态，暂停执行)，函数返回i(0)。 第2次调用function()时, state值为1，执行case 1（相当于恢复状态，继续执行），执行for循环后面的语句，i++， state赋1，函数返回i(1)。 第3次调用function()时, state值为1，执行case 1，执行for循环后面的语句，i++， state赋1，函数返回i(2)。 \u0026hellip;\n第10次调用function()时, state值为1，执行case 1，执行for循环后面的语句，i++， state赋1，函数返回i(9)。 第11次调用function()时, state值为1，执行case 1，因为i\u0026gt;=10所以跳出循环，函数返回i(9)。\n由此可见，通过一个状态量，便可改变每次函数的执行流程。看到这里也许你会有疑问，为什么要用这么复杂的语法，if-else不也可以实现吗？其实这样写主要方便利用宏进行代码封装，具体的做法可见参考文献[15]。其实在C++协程标准的实现里面也有类似的做法，只不过是编译器通过汇编指令直接跳转实现的，具体的分析后面会介绍。\n  它们通过返回到调用方暂停执行。这里说的是协程的非对称性，协程按照调度方式可以分为对称协程和非对称协程[17]。\n 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。  直白的说就是， 对称协程只提供了一种类似于goto的操作将控制权直接传递给其它指定的协程，而非对称协程需要前面所说的“暂停”和“恢复”两种操作。对于对称协程调用者和被调用者之间的关系是平等的，他们甚至可以互相调用，可以做到A-\u0026gt;B-\u0026gt;C-\u0026gt;A（A,B,C为不同的协程函数）这样的链式调用。非对称协程具有明确的层级关系被调用者必须先返回到调用者再调用其他协程，如A-\u0026gt;B-\u0026gt;A-\u0026gt;C-\u0026gt;A。粗看好像对称协程更容易使用，因为其具有更大的自由度，但是它和goto遇到的问题是一样的，在一个复杂的系统里过多的自由跳转会破坏代码的结构，让程序逻辑不容易得到把控。例外对称协程只是非对称协程的一个特例，我们可以通过添加一个中立的第三方调度中心的方式将非对称协程转换成对称协程（只需要在所有协程“暂停”时将控制权转交给调度中心统一调度即可）。\n  并且从栈分离存储恢复所要求的数据。这里所说是相对于普通的函数调用，如图1，图2所示，我们在调用函数时总是会先将调用参数和临时变量以及一些相关寄存器信息压入堆栈，在后面的指令需要时再从堆栈中取出，最后函数执行完后清理掉。但是协程具有额外的“暂停”和“恢复”操作，如果还是使用堆栈上的信息，根据堆栈的使用规则，协程“恢复”后堆栈已经遭到破坏，因为“暂停”后为了使调用者能够正常工作，我们必须保证此时的堆栈状态能够恢复到调用者的堆栈状态，“恢复”后由于协程的堆栈信息已经丢失，我们无法再使用协程的堆栈。所以我们需要额外的手段将这些信息存储在其他地方（一般是在堆上）。值得注意的是这里的用词是“分离”而不是复制，具体实现后面做详细的分析。\n  这允许编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O）。 参考前面代码4的例子。\n  还支持对惰性计算的无限序列上的算法及其他用途。\n  无限序列（infinite sequence）是指一列或一串离散的数字能够与另一组正整数$$\\{0, 1, 2, 3, \u0026hellip;\\}$$相比而形成一定的联系和概念。例如无限序列 $$ N=(0, 1, 2, 3, \u0026hellip;) $$ 和 $$ S＝(1, \\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}, \u0026hellip;, \\frac{1}{2^n}, \u0026hellip;) $$, 当然斐波纳契数列$$ F＝(1, 1, 2, 3, 5, 8, \u0026hellip;, n_{i-1}, n_{i}, n_{i-1} + n_{i}, \u0026hellip;) $$也是一种无限序列。\n  惰性计算（又称延迟求值）在科学计算和函数式编程中经常用到的一种优化手段。引用Wiki中给的例子简单说明下， 下面是部分代码[19]:\nmatrix A,B; A[3][4]=101; B[3][4]=102; matrix_add R=A+B; int result = R[3][4]; 上面的代码是计算两个矩阵（A, B）相加后得到新矩阵(R)某个索引的值。通常我们在执行完R=A+B时便会算出R中的所有元素，因为A和B均有$12=3\\times4$个元素，所以为了得到R需要经过12次加法运算，但是我们只需要R[3][4]这一个元素的值，所以我们浪费了11次运算。惰性计算的方法是执行到R=A+B时，我们并不去计算，而只是存储计算所需要的数据，计算被延迟到了取R[3][4]值时才开始。完整的代码请参考Wiki[19]。\n  我们通过cppcoro计算斐波纳契的例子来说明下C++协程是怎么实现惰性计算的。\ncppcoro::generator\u0026lt;const std::uint64_t\u0026gt; fibonacci() { std::uint64_t a = 0, b = 1; while (true) { co_yield b; // 2  auto tmp = a; a = b; b += tmp; } } void usage() { for (auto i : fibonacci()) // 1  { if (i \u0026gt; 1\u0026#39;000\u0026#39;000) break; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } 在代码注释1处，我们通过循环不停调用fibonacci， 第一次调用fibonacci时从函数入口开始初始化a, b，然后进入循环，执行 co_yield b; 这是会从fibonacci函数回到usage，执行for循环体中代码，再次调用fibonacci时实际上执行的是fibonacci协程的的resume方法，所以再次进入fibonacci函数时并不是从入口重新执行，而是恢复到co_yield后面的语句auto tmp = a;继续执行算出数列的下个值b，然后循环再次co_yield回到usage，如此循环往复，最终得到数列中第1'000'000个值。  可以看到第一次调用时我们并没有把fibonacci数列中的前1'000'000个值全部计算出来，而是把计算推迟到了后面的调用。如果有足够的时间和算力我们可以计算任意数列的值，从算法上并不限制数列的长度，可以无限的计算下去， 所以说是“无限序列”。\n    若函数的定义做下列任何内容之一，则它是协程。 简单的说就是如果一个函数中出现co_await、co_yield、co_return 三个关键字，你就可以认为它是一个协程函数。\n  原理剖析 C++语言的难学已经是恶名远播，提起C++时许多程序员（甚至是学C语言的程序员）第一反应就是“这是个令人胆颤、难缠、恶心的家伙”。其实换个角度C与C++的关系非常类似于JavaScript和Typescript(如果你用过应该很好理解)，C++作为C的超集经过编译器的转换绝大部分的代码是可以转换成C，因为有了编译器的帮助C++可以实现许多高级的封装，每次编译时编译器都会根据需要向用户编写的代码里“偷偷”加料。例如构造析构函数的自动创建、虚函数表、this指针传递等等，对于这方面的知识建议大家看看《深入了解c++内核对象模型》这本书。因为编译器的这些小动作对用户是无感知的，这就造成了用户对C++一些行为表现的困惑，也加大了大家学习C++的难度。而协程特性是我目前见到C++让编译器加料最多的一次，理所当然理解的难度指数也是陡增。现在就让我们细细的分析下编译器给我们加的这些料的配方吧！\n协程函数展开  让我们看个最简单的例子，看看main函数调用remote_query_all时发生了什么。\n我们先定义个函数返回对象的类型return_ignore，为什么要定义它以及怎么定义我们后面介绍，提前申明只是不想干扰后面的分析，如果不清楚具体的含义就先无视它。\nstruct return_ignore { struct promise_type { return_ignore get_return_object() { return return_ignore{}; } auto initial_suspend() { return std::experimental::suspend_always{}; } auto final_suspend() { return std::experimental::suspend_never{}; } void unhandled_exception() { } void return_void() {} }; }; 下面是我们现在需要关注的代码，为了排除干扰我已经做了最大程度的精简。test_coroutine的模板参数其实是不必要的，但是为了通用性还是加上了。\n#include \u0026lt;experimental/coroutine\u0026gt; template\u0026lt;typename ...Args\u0026gt; return_ignore test_coroutine(Args... args) { co_await std::experimental::suspend_always{}; } int main() { test_coroutine(); return 0; } 下面我们看看编译器展开test_coroutine函数后的代码成什么样子， Gor Nishanov和luncliff对其做了精彩的分析，推荐看看他们的报告[21][22]，下面是我结合他们俩的报告整理出来的全部展开：\ntemplate\u0026lt;typename ...Args\u0026gt; return_ignore test_coroutine(Args... args) { using T = coroutine_traits\u0026lt;return_type, Args...\u0026gt;; using promise_type = T::promise_type; using frame_type = tuple\u0026lt;frame_prefix, promise_type, Args...\u0026gt;; auto *frame = (frame_type *)promise_type::operator new(sizeof(frame_type)); auto *p = addressof(get\u0026lt;1\u0026gt;(*frame)); return_ignore*__return_object; *__return_object = { p-\u0026gt;get_return_object() }; { // co_await p-\u0026gt;initial_suspend();  auto\u0026amp;\u0026amp; tmp = p-\u0026gt;initial_suspend(); if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = n;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_n: tmp.await_resume(); } try { // co_await std::experimental::suspend_always{};  { auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_m: p-\u0026gt;return_void(tmp.await_resume()); // p-\u0026gt;return_value(tmp.await_resume());  } goto __final_suspend_point; } catch (...) { p-\u0026gt;unhandled_exception(); } __final_suspend_point: co_await p-\u0026gt;final_suspend(); __destroy_point: promise_type::operator delete(frame, sizeof(frame_type)); } 哈哈，惊不惊喜？意不意外？你的一行代码，编译器给你加了这么多东西。上面的代码对理解协程非常重要，它就像导航地图里面的预览图一样，在你学习协程的各种知识和概念是不被绕晕。我在刚开始学习协程时就因为缺乏对全局的理解，导致当面对一大堆新的概念时不说其它的，心理上就有莫大压力，想理清它们关系也无所适从，希望上面的代码能够帮助到你。\n 注意\n上面的代码并非真实的代码，只是根据文献和逆向推导而来，而且各个编译器厂商实现也有差异，这里列出的代码只是帮助大家理解而已。\n 下面我们对照着上面的代码说说协程的几个重要概念。\nco_await 表达式 co_await 表达式， 就是我们在co_await关键词后面的运算对象(operand)，这个运算对象必须满足特定的规则：必须包含await_ready、await_suspend、await_resume三个函数。通过展开的代码我们很容易理解为什么做这样的规定。例如我们前面例子中std::experimental::suspend_always的定义是这样的：\nstruct suspend_always { bool await_ready() noexcept { return false; } void await_suspend(coroutine_handle\u0026lt;\u0026gt;) noexcept {} void await_resume() noexcept {} }; co_await 表达式展开后是这样的：\n// co_await std::experimental::suspend_always{}; { auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_m: tmp.await_resume(); } 可以看到展开后直接调用了运算对象的await_ready、await_suspend、await_resume三个方法。那么这三个函数式作什么用的呢？\n await_ready: 在暂停协程前给了一次机会，判断是否可以避免异步调用以达到节省暂停带来的开销。 await_suspend：可以看做是暂停前的准备，通常我们在这个函数中分配任务系统，线程去完成异步完成，然后进入暂停状态。注意这个函数有一个非常重要的参数coroutine_handle(协程句柄)，通过这个句柄我们可以操控协程的状态，通常我们需要将这个句柄保存起来，在适当的时机（异步任务完成时）通过它恢复当前协程。 await_resume：这个很好理解，协程恢复后执行的代码，值得注意的是恢复后而不是回复前。  承诺（promise）对象 编译器用 std::coroutine_traits 从协程的返回类型确定 Promise 类型[8]。也就是说编译器会根据你的协程函数放回值类型去确定Promise类型，确定方法就是看你的返回类型有没有promise_type的定义，比如return_ignore的Promise类型就是return_ignore::promise_type。这个Promise类型类似于std::promise，应为是异步所以无法立即给你结果，但是我承诺你将来你可以向我申请查询结果。同样通过展开代码我们可以看到编译器调用了Promise的许多方法，所以我们在定义promise_type时必须符合编译的规范和需求。下面是promise_type必须具有的接口：\n  get_return_object: 按照规定该调用的结果将在协程首次暂停时返回给调用方[8]。调用者可以通过此函数返回的对象获得协程函数最终的结果。可以参考return_ignore的代码，这里需要注意的是我们不能将结果保存在promise_type里，因为协程函数结束时会析构这个对象，保存的数据会丢失。可选的方案是在promise_type中保存返回对象然后在返回去，如下面的代码，但是返回值类型是个问题，如果返回_ret指针，promise_type析构后_ret一样会被收回，返回对象会多出一份数据，return_value函数操作的还不是同一个对象, 所以_value只能是个指针类型。还有个小的问题是直接在内部类声明外面的类对象会导致类型未定义的错误，只能放到类定义外面定义内部类。\nstruct return_object { struct promise_type; int get_ret() { return *_value; } private: std::shared_ptr\u0026lt;int\u0026gt; _value = std::make_shared\u0026lt;int\u0026gt;(0); }; struct return_object::promise_type { return_object get_return_object() { return _ret; } ... void return_value(int value) { *_ret._value = value; } return_object _ret; }; 另一个方案是在promise_type类中提供个方法让返回对象将this指针传给promise_type类，相当于来了个回马枪：\nstruct return_object { struct promise_type { return_object get_return_object() { return return_object(this); } void set_return_object(return_object* ret) { _ret = ret; } auto initial_suspend() { return std::experimental::suspend_never{}; } auto final_suspend() { return std::experimental::suspend_never{}; } void unhandled_exception() { } void return_value(int value) { _ret-\u0026gt;_value = value; } return_object* _ret = nullptr; }; int get_ret() { return _value; } private: return_object(promise_type* p) { p-\u0026gt;set_return_object(this); } int _value = 0; };   initial_suspend: 控制是否在进入协程函数前先暂停协程。\n  initial_suspend: 做些收尾工作。\n  unhandled_exception: 参考展开代码，捕获到异常时调用此方法。\n  return_value, return_void: 这两个函数根据协程函数内的co_return表达式二选一即可，协程函数遇到co_return会根据表达式内容调用这两个函数之一，并将结果传递给放回对象。\n  协程句柄 (coroutine handle) 这是用于恢复协程执行或销毁协程帧的非拥有柄。前面的“承诺对象”是从内部控制协程，将异常和结果传递给系统外部，而协程句柄正好相反，它提供了从外部操控协程的方法。先看下结构声明：\ntemplate \u0026lt;\u0026gt; struct coroutine_handle\u0026lt;void\u0026gt; { // no promise access  static coroutine_handle from_address(void* _Addr); void* address() const noexcept; void operator()() const noexcept { resume(); } void resume() const { _coro_resume(_Ptr); } void destroy() { _coro_destroy(_Ptr); } bool done() const { return _Ptr-\u0026gt;_Index == 0; } struct _Resumable_frame_prefix { using _Resume_fn = void(__cdecl*)(void*); _Resume_fn _Fn; uint16_t _Index; uint16_t _Flags; }; protected: _Resumable_frame_prefix* _Ptr = nullptr; }; 在协程句柄中我们看到一个非常重要的方法resume和一个frame_prefix的成员变量，resume方法应该不用多说了，调用它可以将协程从“暂停”的地方“恢复”。有意思的是_Ptr这个指针，它的类型是_Resumable_frame_prefix, 其中包括一个函数指针_Fn和两个状态值。_Fn其实就是协程跳转后真正执行的函数地址，它通过和_Index配合能够跳转到协程暂停后的指令地址。具体的分析参考后面的协程跳转相关内容。\n协程状态 (coroutine state) 可以把协程状态理解为为使协程正常工作在堆上申请分配的内存，这里面包括前面说过的承诺对象、参数、临时变量和协程句柄里面记录的_Resumable_frame_prefix内容。\n协程跳转 在协程展开代码中还有两个函数__builtin_coro_save和__builtin_coro_suspend，这其实是编译器内置的代码，在msvc的头文件experimental\\resumable中你可以看到许多以_coro_开头的类似函数，这些函数式协程实现的基础。下面我们以一个简单的例子，通过跟踪汇编代码来看下编译器是怎么实现协程的“暂停”和“恢复”操作的。\nstd::experimental::coroutine_handle\u0026lt;\u0026gt; g_h; struct awaitee { bool await_ready() noexcept { return false; } void await_suspend(std::experimental::coroutine_handle\u0026lt;\u0026gt; h) noexcept { g_h = h; } void await_resume() noexcept {} }; template\u0026lt;typename ...Args\u0026gt; return_object test_coroutine(Args... args) { co_await awaitee(); co_return 1; } int main() { auto\u0026amp; ret = test_coroutine(); if (ret.get_ret() == 0) { g_h.resume(); } std::cout \u0026lt;\u0026lt; \u0026#34;coroutine ended.\u0026#34; \u0026lt;\u0026lt; ret.get_ret() \u0026lt;\u0026lt; std::endl; return 0; } ; test_coroutine xor edi,edi mov ecx,100h add rcx,28h call operator new (07FF6282C10CDh) ; 在堆上分配协程帧内存 lea r9,[a] ；向_InitCoro 传递 test_coroutine 参数 a mov dword ptr [rsp+170h],edi mov r8,rbx lea rcx,[rsp+170h] lea rdx,[rax+10h] ; 计算协程句柄地址 lea rax,[b] ；向_InitCoro 传递 test_coroutine 参数 b mov qword ptr [rsp+20h],rax call test_coroutine$_InitCoro$1 (07FF6282C1630h) ; 调用初始化协程的内置函数 请在后面注意这里的内存变化： 这里值得一提的是计算协程句柄地址中的偏移地址10h, 这个值怎么来的呢？ 翻看msvc中resumable头文件，可以看到coroutine_handle的定义：\ntemplate \u0026lt;typename _PromiseT\u0026gt; struct coroutine_handle : coroutine_handle\u0026lt;\u0026gt; { static coroutine_handle from_promise(_PromiseT\u0026amp; _Prom) noexcept { auto _FramePtr = reinterpret_cast\u0026lt;char*\u0026gt;(_STD addressof(_Prom)) + _ALIGNED_SIZE; coroutine_handle\u0026lt;_PromiseT\u0026gt; _Result; _Result._Ptr = reinterpret_cast\u0026lt;_Resumable_frame_prefix*\u0026gt;(_FramePtr); return _Result; } ... static const size_t _ALIGN_REQ = sizeof(void*) * 2; static const size_t _ALIGNED_SIZE = is_empty_v\u0026lt;_PromiseT\u0026gt; ? 0 : ((sizeof(_PromiseT) + _ALIGN_REQ - 1) \u0026amp; ~(_ALIGN_REQ - 1)); _PromiseT\u0026amp; promise() const noexcept { return *const_cast\u0026lt;_PromiseT*\u0026gt;( reinterpret_cast\u0026lt;_PromiseT const*\u0026gt;(reinterpret_cast\u0026lt;char const*\u0026gt;(_Ptr) - _ALIGNED_SIZE)); } }; 从中分析可以知道promise地址（实际上就是协程栈的地址）与协程句柄的帧前缀地址是可以互相转换的，这两个地址之间相差了_ALIGNED_SIZE字节，所以得到一个地址相加或相减便能转换成另一个地址。那么_ALIGNED_SIZE是怎么算出来的呢？其实这是根据我们定义的promise_type的大小进行字节对齐（两倍的sizeof(void*)）得到的。例如我们定义的return_object::promise_type里面有一个指针成员变量，所以它的大小为8（64位机器）在和sizeof(void*) * 2 == 16 == 10h对齐后得到的结果便是16即10h, 如果我们在promise_type里面定义三个指针变量，大小变为24与16字节对齐后变为32即20h。\n下面我们继续分析_InitCoro函数：\nmov qword ptr [rsp+10h],rdx ; 从前面的分析我们知道rdx其实是协程句柄帧前缀的地址 sub rsp,28h mov r11d,100h mov rax,qword ptr [\u0026amp;b] ; 参数b mov r10d,dword ptr [rax] mov eax,dword ptr [r9] ; 参数a mov dword ptr [rdx+r11+10h],eax ; 加参数a, 存入协程栈 mov dword ptr [rdx+r11+14h],r10d ; 将参数b, 存入协程栈 lea rax,[test_coroutine$_ResumeCoro$2 (07FF6282C2FF0h)] ; 协程函数入口地址 mov qword ptr [rdx],rax ; 初始化协程句柄帧前缀的_Fn变量 mov eax,10002h ; 初始化协程句柄帧前缀的_Index和_Flags变量， 注意这里的_Index初始化值为2 mov r9d,2 cmp dword ptr [rcx],0 cmovne eax,r9d mov dword ptr [rdx+8],eax xor eax,eax mov dword ptr [r8],eax mov qword ptr [rdx-10h],r8 ; 初始化我们定义的 promise_type 的 _ret 变量 ; 注意这里的地址是 rdx-10h，即协程帧地址 mov byte ptr [rdx+r11],al mov rcx,rdx call test_coroutine$_ResumeCoro$2 (07FF6282C2FF0h) nop add rsp,28h ret 接着看下_ResumeCoro：\nmov qword ptr [rsp+8],rcx sub rsp,38h mov r8,qword ptr [\u0026lt;coro_frame_ptr\u0026gt;] ; 帧地址 movzx eax,word ptr [r8+8] ; 获得_Index值 mov word ptr [rsp+20h],ax inc ax ; _Index + 1，获得`恢复`索引， _Index为`暂停`索引 cmp ax,8 ja test_coroutine$_ResumeCoro$2+12Dh (07FF6282C311Dh) movsx rax,ax lea rdx,[__ImageBase (07FF6282C0000h)] ; 获取索引表 mov ecx,dword ptr [rdx+rax*4+3124h] ; 计算下条指令的执行地址偏移 add rcx,rdx ; 计算下条指令的执行地址 jmp rcx ; 跳转 这段代码可以说是协程实现的最关键的地方了，通过指令mov ecx,dword ptr [rdx+rax*4+3124h] 我们甚至可以猜测到隐藏在编译器后面整个实现逻辑。因为编译器在编译时知道我们所有代码的执行地址，所以编译器在生成程序时帮我建立了一张表\n   恢复点地址     恢复点1   恢复点2   \u0026hellip;    编译器每次遇到co_await, co_yied, 或者其他需要暂停恢复的地方都往这个表里添加一条记录。在执行时每次暂停，恢复时修改_Index值来动态找到需要跳转的地址。解释下为什么_Index初始化时值为2， 因为第一个暂停点和恢复点时留给cancel操作的。怎么样这里的逻辑是不是有点“达夫设备”的感觉，只是编译器做的更好。下面我们来验证下各个跳转点：\n从上面的代码可以看出，rcx是一个内存映射好的地址，现在让我们分别加上前面的地址偏移看看jmp最终跳转到的代码时什么。\n  第1个 rax = rcx + (rcx+0*4+34E8h) = 0x00007ff7eca10000 + 0x000034a1 （注意这里的字节序，需要反过来取值） = 0x00007ff7eca134a1，\n  第2个 rax = rcx + (rcx+1*4+34E8h) = 0x00007ff7eca10000 + 0x000034cb = 0x00007ff7eca134cb 看下0x00007ff7eca134a1和0x00007ff7eca134cb地址处的代码： 可以很容易的发现这是_resumable_cancel函数的进入和退出点， 同样我们再看看根据后面几个值算出的地址是什么代码。\n  第3个00007FF7ECA13431是 promise_type展开中的 co_await initial_suspend() 代码 这是 co_await initial_suspend() 的代码\n  第4个0x00007ff7eca12c4f是 第一次进入协程函数的代码。\n  第5个0x00007ff7eca12c4a是 0x00007ff7eca12c4f 失败时的恢复点。\n  第6个0x00007ff7eca12e20是 第一次调用 co_await awaitee() 恢复后代码。\n  第7个0x00007ff7eca12e1b是 0x00007ff7eca12e20 失败时的恢复点。\n  第8个0x00007ff7eca130da是 第二次调用 co_await awaitee() 恢复后代码。\n  第9个0x00007ff7eca130d5是 0x00007ff7eca130da 失败时的恢复点。\n从上图可以看到每次失败时都会跳转到 0x00007ff7eca134a1 即 _resumable_cancel函数的进入点。\n  总结 协程最关键的操作是暂停和恢复函数的执行，C++20中的协程借助于编译器在编译期插入相关代码、记录相应跳转点然后运行期根据协程状态计算跳转地址实现协程的各种功能。希望经过本文的讲解和分析后能够帮助大家更为深刻的了解和理解协程的机理，能够让大家放下对协程的恐惧，在以后的使用中能够更加自信。\n比如很多人在使用协程时都会想协程时线程安全的吗？其实在我看来这是个伪命题，既然是问是否是线程安全，那么肯定要出现资源被多个线程竞争的情况。但是从我们前面的例子可以看出整个代码都是在一个线程执行的，所以谈不上线程安不安全。当然如果我们改下前面的代码，将resume的调用放在不同线程里面执行，这种情况下协程函数中如果使用了共享的对象，那肯定不是线程安全的。至于网上许多说协程没有线程安全问题应该是指在一个协程函数中多次暂停和恢复，由于是顺序进行的，所以协程对象上的变量在此过程中不会存在竞争，可以说是线程安全的。总之，线程是否安全关键还是看线程而不是协程，协程只是改变代码执行流程的一种手段。\n在使用协程时，我们关心的另一问题就是性能效率问题。在理解C++的协程原理后我们知道建立一个协程函数后需要建立个协程对象，这个协程对象中包含承诺对象、形参信息、临时变量、协程句柄。与回调函数比起来真正多出来的应该只有协程句柄内包含的信息，承诺对象相当于返回值， 形参和临时变量回调函数也是少不了的（协程经过编译器优化可以直接在堆上分配），而协程句柄的内存也是极少的（只有一个函数指针和两个状态值）。对于执行时间，协程跳转只需计算一个地址然后直接跳转，效率上不会比一次函数调用差多少。所以C++的协程无论是空间还是时间复杂度性能都是相当可观的。\n最后，回到开头我是因为看到asio中的协程示例才开始学习研究C++ Coroutine的，但是此文通篇都没有提及asio， 所以在下篇文章中我会带大家一起学习研究下asio是怎样使用协程实现异步调用的。\n参考引用 [1] C++ compiler support[EB/OL]. https://en.cppreference.com/w/cpp/compiler_support\n[2] \u0026ldquo;Hello, World!\u0026rdquo; program[EB/OL].https://en.wikipedia.org/wiki/%22Hello,_World!%22_program\n[3] C++ Standards Support in GCC[EB/OL].https://gcc.gnu.org/projects/cxx-status.html#cxx98\n[4] std::this_thread::get_id[EB/OL].https://en.cppreference.com/w/cpp/thread/get_id\n[5] User-defined literals[EB/OL].https://en.cppreference.com/w/cpp/language/user_literal%23Standard_library\n[6] reactor反应堆模式[EB/OL].https://aceld.gitbooks.io/libevent/content/31_reactorfan_ying_dui_mo_shi.html\n[7] Proactor and Boost.Asio[EB/OL].https://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio/overview/core/async.html\n[8] Coroutines (C++20) [EB/OL].https://en.cppreference.com/w/cpp/language/coroutines\n[9] 协程 [EB/OL].https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B\n[10] Tencent/libco[EB/OL].https://github.com/Tencent/libco\n[11] Go Language Patterns/Coroutines[EB/OL].http://www.golangpatterns.info/concurrency/coroutines\n[12] setcontext(2) - Linux man page[EB/OL].https://linux.die.net/man/2/setcontext\n[13] Boost.Context[EB/OL].https://www.boost.org/doc/libs/1_74_0/libs/context/doc/html/context/overview.html\n[14] Libco[EB/OL].https://github.com/Tencent/libco\n[15] 使用 C 语言实现协程[EB/OL].https://mthli.xyz/coroutines-in-c/\n[16] 达夫设备[EB/OL].https://en.wikipedia.org/wiki/Duff%27s_device\n[17] 破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现[EB/OL].https://www.bennyhuo.com/2019/12/01/coroutine-implementations/\n[18] infinite sequence：无限序列[EB/OL].https://searchcio.techtarget.com.cn/whatis/8-28809/\n[19] 惰性求值[EB/OL].https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC\n[20] CppCoro - A coroutine library for C++[EB/OL].https://github.com/lewissbaker/cppcoro\n[21] Exploring the C++ Coroutine[EB/OL].https://raw.githubusercontent.com/CppCon/CppCon2016/master/Presentations/C%2B%2B%20Coroutines%20-%20Under%20The%20Covers/C%2B%2B%20Coroutines%20-%20Under%20The%20Covers%20-%20Gor%20Nishanov%20-%20CppCon%202016.pdf\n[22] Exploring the C++ Coroutine[EB/OL].https://luncliff.github.io/coroutine/ppt/%5BEng%5DExploringTheCppCoroutine.pdf\n  ","date":"October 1, 2020","hero":"/posts/c++/coroutine/coroutine.md.assets/hero.jpg","permalink":"https://gqw.gitee.io/posts/c++/coroutine/","summary":"缘起 前一阵子在查看asio库的时候看到在example目录中已经提供了coroutines_ts代码。很是好奇，便慢慢翻看代码，在感叹Coroutine给异步编程带来的优雅简洁的同时也带来了许多概念上的复杂和难以理解。由于C++ Coroutine还是一个比较新的概念，各个编译器厂商的实现还处于实验性的阶段[1] ，网上的资料少而松散。由此内心涌出一个念头想把自己的学习过程记录下来以期帮助后面学习的人。\n从HelloWorld说起 再过两年这个世界的第一条HelloWorld代码就要有50年历史了[2] ，在此先提前蹭下热点，:)\u0026hellip;\n#include \u0026lt;iostream\u0026gt;int main() { std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码1\r这是一段平淡无奇的符合C++98标准的代码，你甚至可以用古董级编译器GCC 4.3都能编译通过[3]。但是我希望通过对这段代码的演化带领大家学习了解C++ 20中的Coroutine。\n这段代码的作用很简单，打印一条\u0026quot;hello, world\u0026quot;，执行的也很快。但是这个世界并不总是那么简单美好，如果打印的逻辑非常耗时（特别是读取磁盘文件和进行网络请求时）而又需要频繁的调用就有些尴尬了，好了，我们改下代码来模拟这种情形：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; void remote_query() { // 假设这是个远程网络请求  std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { for (;;) { remote_query(); } return 0; } 代码2\r改过后的代码不停的进行耗时的远程调用，每次远程调用需要消耗4秒的时间才能返回。可以看到，每次进行调用时程序都要暂停住（也就是卡住）而做不了其它事情。如果这是个带UI(用户界面)的程序，每次进行调用界面就要卡住，用户肯定是不能忍受的。\n 注意\n上面的代码由于使用了thread[4](C++ 11)和chrono_literals[5](C++ 14)，所以编译器需要支持C++ 14标准。\n 多线程+Callback解决方案 为了解决上面的问题，我们对上面的代码进行如下改造：","tags":null,"title":"从HelloWold开始，深入浅出C++ 20 Coroutine TS"}]