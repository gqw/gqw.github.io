[{"categories":null,"contents":"markdown 图片加标注 \r\rHTTP下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 排列图片 \r\rHTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;BT\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/nD9GQ5mOpVv1ESR.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;BT下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 图片横排 HTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;div style=\u0026#34;display: flex;justify-content: space-around;\u0026#34;\u0026gt; \u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;bt\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/nD9GQ5mOpVv1ESR.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;BT下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/div\u0026gt;     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/notes/html/markdown-html/","summary":"markdown 图片加标注 \r\rHTTP下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;     Markdown 排列图片 \r\rHTTP下载方式\r\rBT下载方式\r\r\r\u0026lt;center id=\u0026#34;http\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34; src=\u0026#34;https://i.loli.net/2021/07/26/QVMgJblTeGuY6fO.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026#34;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\u0026#34;\u0026gt;HTTP下载方式\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;center id=\u0026#34;BT\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;border-radius: 0.","tags":null,"title":"Html in markdown"},{"categories":null,"contents":"gcc 源文件编译 # 下载，解压 tar -xf gcc-11.1.0.tar.xz cd gcc-11.1.0.tar # 安装必要编译工具 sudo apt install build-essential # 安装依赖库 sudo apt install libgmp-dev # 生成makefile文件 ./configure # 编译安装 make -j 10 sudo make install     从PPA安装 sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install gcc-11 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 110 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/notes/linux/env/","summary":"gcc 源文件编译 # 下载，解压 tar -xf gcc-11.1.0.tar.xz cd gcc-11.1.0.tar # 安装必要编译工具 sudo apt install build-essential # 安装依赖库 sudo apt install libgmp-dev # 生成makefile文件 ./configure # 编译安装 make -j 10 sudo make install     从PPA安装 sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install gcc-11 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 110 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11     ","tags":null,"title":"Linux环境配置"},{"categories":null,"contents":"wsl2 默认root登录 [HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Lxss\\{a7b6183f-cc3e-4388-a97a-502a98efca90}] \u0026#34;DefaultUid\u0026#34;=dword:00000000 设置 DefaultUid 为0\n    wsl2 限制CPU和内存大小 创建 %UserProfile%\\.wslconfig 添加如下内容\n[wsl2] memory=4GB # Limits VM memory in WSL 2 to 4 GB processors=4 # Makes the WSL 2 VM use two virtual processors     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/notes/linux/wsl/","summary":"wsl2 默认root登录 [HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Lxss\\{a7b6183f-cc3e-4388-a97a-502a98efca90}] \u0026#34;DefaultUid\u0026#34;=dword:00000000 设置 DefaultUid 为0\n    wsl2 限制CPU和内存大小 创建 %UserProfile%\\.wslconfig 添加如下内容\n[wsl2] memory=4GB # Limits VM memory in WSL 2 to 4 GB processors=4 # Makes the WSL 2 VM use two virtual processors     ","tags":null,"title":"wsl"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"问题 在学习强化学习时用到gym。在Windows上跑gym总有诸多不便，所以直接将环境切到Linux下。开始方案是使用Win 10的Ubuntu子系统wsl2。按照网上教程虽然没有弄明白原理但是还算顺利，Linux的Gui程序还是能正常跑起来的。最近双11腾讯云搞促销就卖了3年的云主机，买了以后发现自己也没什么需要放在上面跑的东西，就寻思能不能将gym环境搬到云上，这样也就省得在公司机器和家里的机器上来回切换的麻烦了。但是今天在操作的时候还是遇到了不少的问题，现在记录下来以作备忘。\n解决方法   首先到SourceForge上下载最新的VcXsrv\n  安装运行\n  启动后出现如下界面：\n这里有两个选项，第一个是程序的窗口风格：\n  Multiple windows: 多窗口模式，即每个GUI进程一个窗口\n  One large windows: 单窗口模式，和远程桌面类似，所有窗口都在一个大窗口里\n  Fullscreen：全屏模式，与单窗口模式类是只不过大窗口是全屏的\n  One window without titlebar: 与标题单窗口模式，与单窗口模式类似\n  可以更具需求自己的喜好随便选择就可以了。\n窗口模式选项下面是Display number选项，这个选项很重要，但是大多数的教程里面都没有介绍这个选项的意义，害的我在后面解决云主机连接时一直忽略了这个选项，走了挺多弯路。这个选项代表的是vcXsrv模拟的是第几个显示器的意思，说他重要是因为它和通信有着直接的关系。看了别人的教程和使用后你可能心中会有个疑问，vcXsrv毕竟是个网络服务器，但是怎么就是找不到设置和修改服务端口的地方呢？其实这里的的Display number干的就是这件事，x server使用的端口其实是个‘’知名‘’端口(6000)，而实际使用的端口为6000+(Display Number), 比如如果你设置为0，那么服务监听端口变为6000，而如果是1，则端口为6001，依次类推。\n后面一个界面没什么好说的，选“start no client”好了。\n下一个界面：\n有个选项挺重要的，Disable access control 这个选项必须勾选否则会出现认证失败的提示。\nroot@H:~# xcalc Authorization required, but no authorization protocol specified Error: Can\u0026#39;t open display: 172.30.128.1:0 最后一个界面：\n有个save configuration的按钮，它可以将你前面的设置保存到一个以.xlaunch为后缀的文件中，以后只要双击这个文件就可以使用同样的配置了，一下是我的配置：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;XLaunch WindowMode=\u0026#34;MultiWindow\u0026#34; ClientMode=\u0026#34;NoClient\u0026#34; LocalClient=\u0026#34;False\u0026#34; Display=\u0026#34;0\u0026#34; LocalProgram=\u0026#34;xcalc\u0026#34; RemoteProgram=\u0026#34;xterm\u0026#34; RemotePassword=\u0026#34;\u0026#34; PrivateKey=\u0026#34;\u0026#34; RemoteHost=\u0026#34;\u0026#34; RemoteUser=\u0026#34;\u0026#34; XDMCPHost=\u0026#34;\u0026#34; XDMCPBroadcast=\u0026#34;False\u0026#34; XDMCPIndirect=\u0026#34;False\u0026#34; Clipboard=\u0026#34;True\u0026#34; ClipboardPrimary=\u0026#34;True\u0026#34; ExtraParams=\u0026#34;\u0026#34; Wgl=\u0026#34;False\u0026#34; DisableAC=\u0026#34;True\u0026#34; XDMCPTerminate=\u0026#34;False\u0026#34;/\u0026gt;  软件安装完，启动后windows这边事情就结束了。\n  在Linux机器上，我们需要设置下DISPLAY环境变量，因为x client会使用此环境变量\n{{ hostname }}:{{ D }}.{{ S }}   {{ hostname }} 表示运行 X Client 的主机名（域名或 IP 地址），如果省略（如 :0.0）则表示使用 localhost。这里的hostname便是vcXsrv或者其他X Server的IP地址，在wsl上面比较简单，因为wsl虚拟机和Windows主机都在同一台机器上，所以他们在同一局域网，可以直接访问互联，只要将hostname设为主机的IP即可。这里还有个小技巧，如果写死IP地址，主机的IP变动后也要跟着改还是挺麻烦的，网上有人给出了下面的解决方案：\nexport DISPLAY=\u0026#34;$(grep nameserver /etc/resolv.conf | sed \u0026#39;s/nameserver //\u0026#39;):0\u0026#34; 这里的脚本$(grep nameserver /etc/resolv.conf | sed 's/nameserver //')意思是在resolv.conf文件中查找nameserver对应的IP地址。在wsl中nameserver即虚拟机的DNS服务器被设置为桥接路由的IP，而桥接路由正好是Windows主机，所以这个地址也代表了主机地址，所以说这是个技巧而不是通用的方法。\n**总之，这个hostname一定要设置为可访问的vcXsrv服务器地址。**对于想让外网云主机上GUI运行在本地机器的情况稍微有点麻烦。因为本地的主机通常隐藏在本地局域网中，外网不能直接访问。\n在这里我采取的方法是使用ssh的端口映射将Windows本地主机上的vcXsrv服务端口映射到远程云主机的本地端口上，实现将X Client的数据流转发到vcXsrv服务器上。方法很简单只需要在普通的ssh连接参数上添加-R参数：\nssh -R localhost:6000:localhost:6000 username@server 前面的localhost:6000代表windows本地的地址和端口，后面的代表Linux的地址和端口。这样Linux机器上的程序访问6000端口就会转发到Windows机器上的6000端口。原理就是ssh连接成功后便会自动添加指定端口的服务监听，任何访问此服务的数据都会转发到ssh客户机对应的端口上。通过ssh的端口映射，我们最终就可以在远程云主机上访问本地Windows上的vcXsrv服务了。\n接下来我们只需要设置DISPLAY环境变量为:\nexport DISPLAY=localhost:0 便可以了。\n  {{ D }} 是一个序列号，一个 X 连接使用一个序列号，如果有多个 X Client 向外连接，则必须使用不同的 {{ D }}。并且它与一对 C/S 连接使用的端口号相关，Port = D + 6000\n这里的{{ D }}一定要与前面vcXsrv里面设置的Display number保持一致，因为这个用来计算连接端口的\n  {{ S }} 是屏幕序号，一个 display 可以在多个屏幕上显示。 display 是指通过同一个 X 连接传递的窗口。如果只有一个屏幕，则使用 0 作为序号（多的屏幕则依次递增）\n      参考信息 [1]TCP/UDP端口列表[J]. 维基百科，自由的百科全书, 2021.\n[2]VcXsrv 远程连接 · Issue #15 · zombie110year/blog-source[EB/OL]. GitHub, [2021-11-12]. https://github.com/zombie110year/blog-source/issues/15.\n[3]玩转SSH端口转发[EB/OL]. [2021-11-12]. https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/.\n","date":"November 12, 2021","hero":"/posts/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/linux_remote_gui_use_vcxsvr/imgs/vcXsrv.jpg","permalink":"https://gqw.gitee.io/posts/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/linux_remote_gui_use_vcxsvr/","summary":"问题 在学习强化学习时用到gym。在Windows上跑gym总有诸多不便，所以直接将环境切到Linux下。开始方案是使用Win 10的Ubuntu子系统wsl2。按照网上教程虽然没有弄明白原理但是还算顺利，Linux的Gui程序还是能正常跑起来的。最近双11腾讯云搞促销就卖了3年的云主机，买了以后发现自己也没什么需要放在上面跑的东西，就寻思能不能将gym环境搬到云上，这样也就省得在公司机器和家里的机器上来回切换的麻烦了。但是今天在操作的时候还是遇到了不少的问题，现在记录下来以作备忘。\n解决方法   首先到SourceForge上下载最新的VcXsrv\n  安装运行\n  启动后出现如下界面：\n这里有两个选项，第一个是程序的窗口风格：\n  Multiple windows: 多窗口模式，即每个GUI进程一个窗口\n  One large windows: 单窗口模式，和远程桌面类似，所有窗口都在一个大窗口里\n  Fullscreen：全屏模式，与单窗口模式类是只不过大窗口是全屏的\n  One window without titlebar: 与标题单窗口模式，与单窗口模式类似\n  可以更具需求自己的喜好随便选择就可以了。\n窗口模式选项下面是Display number选项，这个选项很重要，但是大多数的教程里面都没有介绍这个选项的意义，害的我在后面解决云主机连接时一直忽略了这个选项，走了挺多弯路。这个选项代表的是vcXsrv模拟的是第几个显示器的意思，说他重要是因为它和通信有着直接的关系。看了别人的教程和使用后你可能心中会有个疑问，vcXsrv毕竟是个网络服务器，但是怎么就是找不到设置和修改服务端口的地方呢？其实这里的的Display number干的就是这件事，x server使用的端口其实是个‘’知名‘’端口(6000)，而实际使用的端口为6000+(Display Number), 比如如果你设置为0，那么服务监听端口变为6000，而如果是1，则端口为6001，依次类推。\n后面一个界面没什么好说的，选“start no client”好了。\n下一个界面：\n有个选项挺重要的，Disable access control 这个选项必须勾选否则会出现认证失败的提示。\nroot@H:~# xcalc Authorization required, but no authorization protocol specified Error: Can\u0026#39;t open display: 172.30.128.1:0 最后一个界面：\n有个save configuration的按钮，它可以将你前面的设置保存到一个以.xlaunch为后缀的文件中，以后只要双击这个文件就可以使用同样的配置了，一下是我的配置：\n\u0026lt;?xml version=\u0026#34;1.","tags":null,"title":"在Windows中运行远程Linux图形程序"},{"categories":null,"contents":"本文是coro_redis项目的开发手记，其较为详尽的描述了其开发过程中遇到的问题和解决方案以及学习心得。希望能和大家共同努力和完善此项目。项目地址为： https://github.com/gqw/coro_redis\n自从上次写完《从HelloWold开始，深入浅出C++ 20 Coroutine TS》已经有一阵子没有写C++代码了，在那篇文章中给自己立了FLAG说要继续写一篇关于asio中使用协程开发的文章也一直没有兑现。现在趁着空闲用协程写了一个redis client库。\n代码还是像mrpc一样追求少而精，希望大家能够学会怎样使用c++的协程，而不是直接把库拿过去用。\n协程是从C++20开始被加进标准库的，但是仅支持基本的协程功能，用起来还不是很方便，估计需要等到C++23才能完善（请参考：C++23的目标）。VisualStudio 2022 PREVIEW（ToolSet v143）已经正式支持协程，相关头文件也已经从experimental目录移到正式目录，并且不需再添加 /await 编译选项（v143之前使用协程请参考/await选项说明）。GCC从10.0版本开始支持协程，11.0版本不再是experimental，但还是需要 -fcoroutines 编译选项（请参考：C++ Standards Support in GCC）。\n以下是开发使用的环境：\n   windows linux     Windows 10 版本 2004 Ubuntu 20.04.2 LTS(wsl2)   Visual Studio 2022(v143) GCC 11.1.0   cmake version 3.21.1 cmake version 3.21.1   Vcpkg version 2021-07-26-9425cf5f512f242c0bcbabac31f08832825aee81 Same as Windows    编译说明  安装vcpkg 设置并导出环境变量 VCPKG_ROOT 为 vcpkg 根目录 如果再Winodws下开发，由于Visual Studio还是预览版，vcpkg默认不会使用，所有需要在%VCPKG_ROOT%/triplets目录下添加x86-windows-v143.cmake文件，内容如下：  \tset(VCPKG_TARGET_ARCHITECTURE x86) set(VCPKG_CRT_LINKAGE dynamic) set(VCPKG_LIBRARY_LINKAGE dynamic) set(VCPKG_PLATFORM_TOOLSET \u0026quot;v143\u0026quot;) set(VCPKG_DEP_INFO_OVERRIDE_VARS \u0026quot;v143\u0026quot;) 安装cmake 执行cmake_build_x64_linux.sh(Linux) 或 cmake_build_x86-v143.bat(Windows)脚本，安装依赖包和生成工程文件  使用方法 协程调用通用命令：\ntask\u0026lt;void\u0026gt; watchdog::coro_call_test_cmds(std::string_view msgs) { std::stringstream ss(std::string(msgs.data(), msgs.size())); std::string msg; while (std::getline(ss, msg, \u0026#39;;\u0026#39;)) { auto reply = co_await redis_client::get().coro_command\u0026lt;void\u0026gt;(msg); if (!reply.has_value()) { continue; } auto r = reply.value(); if (r) { LOG_INFO(\u0026#34;echo return, type: {}, integer return: {}, content: {}\u0026#34;, r-\u0026gt;type, r-\u0026gt;integer, std::string(r-\u0026gt;str, r-\u0026gt;len)); } } } 或者调用封装的方法：\ntask\u0026lt;void\u0026gt; watchdog::coro_call_test() { auto r = co_await redis_client::get().coro_echo(\u0026#34;test\u0026#34;); auto var1 = co_await redis_client::get().coro_incr(\u0026#34;var1\u0026#34;); auto var2 = co_await redis_client::get().coro_incr(\u0026#34;var2\u0026#34;); auto var3 = std::to_string(var1.value() + var2.value()); co_await redis_client::get().coro_set(\u0026#34;var3\u0026#34;, var3); auto var3_2 = co_await redis_client::get().coro_get(\u0026#34;var3\u0026#34;); LOG_DEBUG(\u0026#34;r: {}, var1: {}, var2: {}, var3: {}, var3_2: {}\u0026#34;, r.value(), var1.value(), var2.value(), var3, var3_2.value()); } 具体使用请参考测试代码：examples/301\n代码说明 协程的本质，是通过代码的封装使得异步调用看起来更像同步调用，使得在一个协程函数内部的代码执行顺序能够像普通函数那样按照代码书写的顺序执行。就像前面例子中coro_call_test 协程函数内部虽然每行co_await后面调用都是异步调用，但是协程通过“暂停”、“恢复”的方式能够保证在一次协程函数调用过程中，代码是被从上到下依次执行的，不会出现前后颠倒，也不会并发执行。比如在得到var1前肯定不会去计算var2, 在得到var2前也不会执行求var3的代码。总之代码的执行顺序和你看到的顺序是一致的。那它与普通的函数有什么区别呢？区别在于每次执行比较耗时的操作，如远程方法调用普通的函数一直等待，并且一直占用线程资源，CPU做不了其他事情，干等。但是协程函数不一样，遇到比较耗时的操作它会挂起自己，暂停执行后面的逻辑，让出线程资源让宝贵的CPU执行其他代码指令，等到合适的时机（例如，已经得到远程方法的返回结果）再恢复执行刚才暂停后的代码。 这样协程函数的调用就会变成 “运行-\u0026gt;暂停-\u0026gt;恢复运行-\u0026gt;暂停-\u0026gt;恢复运行-\u0026gt;\u0026hellip;” 这样下去，并且暂停期间并不占用CPU资源。\n利用协程的特性我们便可以对现有的异步代码进行改造了， 使得异步调用的代码看起来像同步代码一样简单，清晰，符合直觉，但是还能保持异步调用的效率。\n既然是对异步调用的封装，那么让我们看看reids的异步调用的代码是怎么写的，这里我们选用Redis官方给出的的hiredis库，在此基础上进行协程封装。\nint redis_asynccall_test(std::string_view host, uint16_t port) { auto actx = redisAsyncConnect(host.data(), port); ASSERT_RETURN(actx != nullptr, 1, \u0026#34;connect redis failed, {}:{}\u0026#34;, host, port); ASSERT_RETURN(actx-\u0026gt;err == 0, 1, \u0026#34;connect redis failed, {}:{}\u0026#34;, actx-\u0026gt;err, actx-\u0026gt;errstr); struct event_base* base = event_base_new(); redisLibeventAttach(actx, base); ... redisAsyncCommand(actx, [](struct redisAsyncContext*, void* reply, void*){ redisReply *r = (redisReply *)reply; LOG_INFO(\u0026#34;echo return, type: {}, integer return: {}, content: {}\u0026#34;, r-\u0026gt;type, r-\u0026gt;integer, std::string(r-\u0026gt;str, r-\u0026gt;len)); }, nullptr, \u0026#34;echo %s\u0026#34;, \u0026#34;hello async\u0026#34;); event_base_dispatch(base); event_base_free(base); return 0; } 这里最需关心的是redisAsyncCommand函数，如果我们想要实现coro_call_test函数效果，我们可能需要写出如下代码：\nstruct result { std::string r; int var1; int var2; std::string var3; std::string var3_2; }; auto pret = new result; redisAsyncCommand(actx, [](struct redisAsyncContext* actx, void* reply, void* p){ redisReply *r = (redisReply *)reply; result* pret = (result*)p; pret-\u0026gt;r = std::string(r-\u0026gt;str, r-\u0026gt;len); redisAsyncCommand(actx, [](struct redisAsyncContext* actx, void* reply, void* p) { redisReply* r = (redisReply*)reply; result* pret = (result*)p; pret-\u0026gt;var1 = r-\u0026gt;integer; redisAsyncCommand(actx, [](struct redisAsyncContext* actx, void* reply, void* p) { redisReply* r = (redisReply*)reply; result* pret = (result*)p; pret-\u0026gt;var2 = r-\u0026gt;integer; pret-\u0026gt;var3 = std::to_string(pret-\u0026gt;var1 + pret-\u0026gt;var2); redisAsyncCommand(actx, [](struct redisAsyncContext* actx, void* reply, void* p) { redisReply* r = (redisReply*)reply; result* pret = (result*)p; pret-\u0026gt;var2 = r-\u0026gt;integer; redisAsyncCommand(actx, [](struct redisAsyncContext* actx, void* reply, void* p) { redisReply* r = (redisReply*)reply; result* pret = (result*)p; pret-\u0026gt;var3_2 = std::string(r-\u0026gt;str, r-\u0026gt;len); LOG_DEBUG(\u0026#34;r: {}, var1: {}, var2: {}, var3: {}, var3_2: {}\u0026#34;, pret-\u0026gt;r, pret-\u0026gt;var1, pret-\u0026gt;var2, pret-\u0026gt;var3, pret-\u0026gt;var3_2); }, pret, \u0026#34;get\u0026#34;, \u0026#34;var3\u0026#34;); }, pret, \u0026#34;set\u0026#34;, \u0026#34;var3\u0026#34;, pret-\u0026gt;var3.c_str()); }, pret, \u0026#34;incr\u0026#34;, \u0026#34;var2\u0026#34;); }, pret, \u0026#34;incr\u0026#34;, \u0026#34;var1\u0026#34;); }, pret, \u0026#34;echo %s\u0026#34;, \u0026#34;test\u0026#34;); 通过简单的对比便可以看出协程代码的优势与优雅。上面的代码实际情况可能会更加复杂，因为我们并没有处理异常情况和资源释放问题，工程实践中的处理逻辑也应该会更复杂。希望能够通过这个简单的例子能够帮你建立起对协程的好感。好了，下面就让我们来看看协程是怎么做到这么优雅的事情的。\n对于异步调用，我们可以将其拆分成两个基本操作——发起异步调用和处理回调结果。 等等，这话是不是有点熟悉，刚才我们在说协程时好像也将协程分成两个步骤——“暂停”和“恢复”。仔细回味下，“发起异步调用”是不是有“暂停”的味道，是不是将任务交给其它人执行，然后自己暂停相关的逻辑，将CPU资源让给别人， 同样“处理回调结果”也意味着从前面停止的地方恢复逻辑处理。区别在于异步调用，“暂停”和“恢复”的代码是分开的（调用函数和回调函数），而协程更像是“胶水”一样将这两者连接在了一起。\n协程实现细节 那么协程是怎样做到的呢？ 协程的使用是简单优雅的，但是协程的实现却是繁杂且充满陷阱的，就像C++其它技术一样简单留给使用者，灵活强大留给库实现者。对协程实现原理感兴趣的可以看下我的另一篇文章《从HelloWold开始，深入浅出C++ 20 Coroutine TS》，在此借用下里面协程展开的代码（后面简称“展开式”），方便大家理解后面的代码：\ntemplate\u0026lt;typename ...Args\u0026gt; return_ignore test_coroutine(Args... args) { using T = coroutine_traits\u0026lt;return_type, Args...\u0026gt;; using promise_type = T::promise_type; using frame_type = tuple\u0026lt;frame_prefix, promise_type, Args...\u0026gt;; auto *frame = (frame_type *)promise_type::operator new(sizeof(frame_type)); auto *p = addressof(get\u0026lt;1\u0026gt;(*frame)); return_ignore*__return_object; *__return_object = { p-\u0026gt;get_return_object() }; { // co_await p-\u0026gt;initial_suspend();  auto\u0026amp;\u0026amp; tmp = p-\u0026gt;initial_suspend(); if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = n;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_n: tmp.await_resume(); } try { auto retm, retn, ...; // co_await std::experimental::suspend_always{}; \t{ auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m; \tif (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp \t} } resume_label_m: retm = tmp.await_resume(); } // co_await std::experimental::suspend_always{}; \t{ auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = n; \tif (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp \t} } resume_label_n: retn = tmp.await_resume(); } // co_return ... \tauto ret = ...; p-\u0026gt;return_value(ret); goto __final_suspend_point; } catch (...) { p-\u0026gt;unhandled_exception(); } __final_suspend_point: co_await p-\u0026gt;final_suspend(); __destroy_point: promise_type::operator delete(frame, sizeof(frame_type)); } 上面的代码便是C++编译器在我们写协程函数时给我们“偷偷”添加的代码，理解了上面的代码也就基本理解了协程。\n协程表达式 我们看下examples/300/代码，这是一个比较简单的协程DEMO，在协程函数task_test中我们首先关注下关键字co_await后面被称为协程表达式的代码。\ntask\u0026lt;int\u0026gt; task_test() { int i = 0; auto ret = co_await task_awaiter\u0026lt;int\u0026gt;([i](coro::coroutine_handle\u0026lt;task_promise\u0026lt;int\u0026gt;\u0026gt;){ std::cout \u0026lt;\u0026lt; \u0026#34;wait set: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; }, [i]() -\u0026gt; std::optional\u0026lt;int\u0026gt;{ std::cout \u0026lt;\u0026lt; \u0026#34;resume set: \u0026#34; \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; std::endl; return i + 1; }); i = *ret; ret = co_await task_awaiter\u0026lt;int\u0026gt;([i](coro::coroutine_handle\u0026lt;task_promise\u0026lt;int\u0026gt;\u0026gt;){ std::cout \u0026lt;\u0026lt; \u0026#34;wait set: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; }, [i]() -\u0026gt; std::optional\u0026lt;int\u0026gt;{ std::cout \u0026lt;\u0026lt; \u0026#34;resume set: \u0026#34; \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; std::endl; return i + 1; }); i = *ret; ret = co_await task_awaiter\u0026lt;int\u0026gt;([i](coro::coroutine_handle\u0026lt;task_promise\u0026lt;int\u0026gt;\u0026gt;){ std::cout \u0026lt;\u0026lt; \u0026#34;wait set: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; }, [i]() -\u0026gt; std::optional\u0026lt;int\u0026gt;{ std::cout \u0026lt;\u0026lt; \u0026#34;resume set: \u0026#34; \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; std::endl; return i + 1; }); i = *ret; co_return i; } C++ 标准中规定协程表达式必须具有await_ready, await_suspend, await_resume 三个方法，也就是说一个对象只有拥有了这三个方法才可以被co_await/co_yield调用。参考上面的协程函数展开式可以知道这三个函数的作用。await_ready可以先不用看，这只是一个优化手段，用于决定要不要真正调用await_suspend。剩下的await_suspend, await_resume两个方法便对应我们前面说的暂停和恢复，你也可以把他俩简单的看成“触发异步调用”和“回调函数”，虽然并不一样但是为了方便理解可以暂且这么认为。下面让我们看下task_awaiter的定义：\ntemplate\u0026lt;typename T\u0026gt; struct task_awaiter { task_awaiter(std::function\u0026lt;void(coro::coroutine_handle\u0026lt;task_promise\u0026lt;T\u0026gt;\u0026gt;)\u0026gt; suspend_callback, std::function\u0026lt;std::optional\u0026lt;T\u0026gt;()\u0026gt; resume_callback) : suspend_callback_(suspend_callback), resume_callback_(resume_callback) { } bool await_ready() const noexcept { return false; } void await_suspend(coro::coroutine_handle\u0026lt;task_promise\u0026lt;T\u0026gt;\u0026gt; coroutine) { if (suspend_callback_) suspend_callback_(coroutine); } decltype(auto) await_resume() noexcept { return resume_callback_(); } private: std::function\u0026lt;void(coro::coroutine_handle\u0026lt;task_promise\u0026lt;T\u0026gt;\u0026gt;)\u0026gt; suspend_callback_; std::function\u0026lt;std::optional\u0026lt;T\u0026gt;()\u0026gt; resume_callback_; }; 在这里我们按照规定，我们定义了await_ready, await_suspend, await_resume这三个方法。 这三个方法的内容也非常简单， await_ready 非常直接的返回false, 表示我们每次调用都会暂停协程，不需要做优化。 await_suspend, await_resume 也只是简单的调用从构造函数获得的回调函数， 之所以这样做只是为了让task_awaiter保持稳定，我们可不希望每次co_await/co_yeild调用都要定义一个新的协程表达式。让变化的部分放到外面调用的地方，在suspend_callback_函数中我们可以定义各种触发异步调用的代码，例如 socket.async_readsome, redisAsyncCommand等等， resume_callback_ 里面便可以是我们以前我们定义的回调函数内容了。\n回看协程展开式，co_await调用对应这段代码：\n// co_await std::experimental::suspend_always{}; \t{ // auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; \tauto\u0026amp;\u0026amp; tmp = task_awaiter\u0026lt;T\u0026gt;{...}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m; \tif (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp \t} } resume_label_m: retm = tmp.await_resume(); } 首先程序会生成协程表达式对象tmp，再检查tmp的await_ready的结果，如果await_ready返回true, 表示此次调用不需要暂停，可以直接通过await_resume拿到结果。如果为false，则先保存“suspend_index”（这个字段在vs2017中的resumable头文件_Resumable_frame_prefix结构体中有定义，vs2022中未见到）它代表的是在这个协程函数中的第几次暂停，恢复的时候会根据这个值计算出resume_label_m的指令地址（每个恢复点的地址编译器是已知的，编译器还会为每个协程函数建立一个恢复点的索引数组，这样根据suspend_index便能计算出恢复点位置）， 然后在调用await_suspend，我们可以将发起请求的代码放在这个函数里面执行，调用完后，会将本次协程调用挂起，执行指令会恢复到上次调用协程函数的地方或者恢复到调用resume的地方。当在适当的时候，当程序需要恢复执行协程函数后面的代码时，协程会更具前面记录的suspend_index找到 resume_label_m 然后便可以执行await_resume函数了。\n这里有个地方需要注意下， await_suspend 返回值有void或bool两种形式， 如果是bool, 则功能与await_ready函数类似，所以个人感觉await_ready的规定有点多余，还增加了本来就复杂的协程复杂性。\n协程句柄 看到这里你可能还会有些困惑，协程到底是什么时候恢复执行的呢？前面一直说在“适当”的时候，但到底什么时候才是“适当”的时候呢？还有是谁触发了恢复动作？还有是怎么触发的？\n谁触发的？ 代码实现者。系统和编译器都是无权也无法控制协程的暂停和恢复，因为他们不知道什么时候该暂停与恢复。一切主动权和责任都在于代码实现者。\n什么时间？ 获得调用结果的时候。在获得异步调用的结果后便可以恢复, 比如在 coro_reids中我们就是在redisAsyncFormattedCommand回调函数中调用的resume方法的。\n怎么触发？ 通过调用协程函数关联的协程句柄coro::coroutine_handle\u0026lt;\u0026gt;的resume()方法恢复。协程句柄的获得途径有以下几种：\n await_resume 的参数 协程返回对象的构造函数参数 通过promise的地址。coro::coroutine_handle\u0026lt;\u0026gt;有个静态方法from_promise，可以通过promise地址直接得到 通过协程帧地址。同样是coro::coroutine_handle\u0026lt;\u0026gt;有个静态方法from_address  协程函数返回类型 协程函数返回类型是一个比较奇怪和复杂的类型, 通过它我们才有了一个从外部操控协程的机会。前面说的协程句柄其实有个promise_type的模版参数（即coro::coroutine_handle\u0026lt;promise_type\u0026gt;），那么这个模版参数是怎么来的呢？通过以下的特征函数获得：\ntemplate \u0026lt;class _Ret\u0026gt; struct _Coroutine_traits\u0026lt;_Ret, void_t\u0026lt;typename _Ret::promise_type\u0026gt;\u0026gt; { using promise_type = typename _Ret::promise_type; }; 这里的_Ret便是协程函数返回类型，这样一来，如果不特化这个结构体，_Ret就必须要有promise_type子类型。说白了，就是你在定义返回类型时必须定义个promise_type子类型。 而这promise_type又要具有以下几个规定的方法：\n get_return_object initial_suspend final_suspend return_void/return_value unhandled_exception  这些定义有许多反直觉的地方和陷阱。\n我们再次回看协程展开式，看下开头的几行，协程帧创建的过程：\nusing promise_type = T::promise_type; using frame_type = tuple\u0026lt;frame_prefix, promise_type, Args...\u0026gt;; auto *frame = (frame_type *)promise_type::operator new(sizeof(frame_type)); 协程帧指的是每个协程函数所使用的内存空间，看上面的代码协程帧正是通过promise_type的new方法在堆上分配出来的（如果不重载operator new方法），但是值得注意的是new的大小并不是promise_type自己的大小，而是带上frame_prefix + promise_type + Args的大小， frame_prefix在vs2017中的定义如下，vs2020已经改为编译器内置函数，头文件里已经看不到了：\nstruct _Resumable_frame_prefix { typedef void(__cdecl *_Resume_fn)(void *); _Resume_fn _Fn; uint16_t _Index; uint16_t _Flags; }; _Fn 是个固定的编译器内嵌的函数地址， _Index 便是前面提到的suspend_index根据这个值可以计算出协程恢复地址，_Flags 不太清楚其原理。\n除此之外协程帧还包含协程函数的参数和临时变量的空间，由于这些变量都是在堆上分配的，所以在整个协程函数执行过程中这些变量都是有效的，在visual studio Debug版本中这些变量是还是先在栈上分配，再拷贝到协程帧上，但是Release版本中由于栈上的变量一直没有用到所以直接优化掉了，所以协程帧上的变量使用和栈上的变量效果是一样的。\n有了协程帧，通过计算我们就可以得到promise_type对象了，先在我们看下它的几个方法：\n  get_return_object 这个方法也挺奇怪的，首先这个方法的返回值类型必须是promise_type的外部类，即例子中的task\u0026lt;T\u0026gt;, 需要注意的是这个返回值不能是指针类型。他必须能够直接赋值给协程函数的返回值。另外是谁什么时间调用了这个方法呢？ 首先get_return_object并不是给协程外部使用的，而是协程内部使用的，其次它是在协程第一次暂停后返回给接受者的，而不是在整个协程调用结束后给的，这点有点反直觉。\n  initial_suspend/final_suspend 这两个函数给了协程函数在进入和退出的时候暂停的机会。\n  return_void/return_value 这两个函数是二选一的关系，如果返回值是void类型协程就会调用return_void，如果非void类型就会调用return_value方法。是的, void在模版编程里面总是个麻烦鬼，所以你最好使用例子中的那种方法先写个基类再对有值和无值分别做特化处理。协程函数通过这个方法将最终的结果传递出去，但是有个陷阱是return_values虽然是promise_type的成员方法，但是我们通常却不能把结果存放在promise_type对象中，我们再次回到协程展开式的最后：\n  auto ret = ...; p-\u0026gt;return_value(ret); // 设置返回值  goto __final_suspend_point; __final_suspend_point: co_await p-\u0026gt;final_suspend(); __destroy_point: promise_type::operator delete(frame, sizeof(frame_type)); // 刚设置完，就销毁了，来不及使用 设置完返回值后promise就被立即销毁了， 这时如果我们通过返回对象拿到promise，再通过promise获得返回值已经晚了。比如下面的代码：\ntemplate\u0026lt;typename T\u0026gt; class task\u0026lt;T\u0026gt; { ... T return_value() { return h_coro_.promise().get_return_value(); } } 有什么方法解决这个问题呢？ 有两个方法：\n 想办法在promise_type::return_value(T value)方法中给task的成员方法赋值。如：  template\u0026lt;typename T\u0026gt; class task_promise final : public task_promise_base { public: using task_return_type = task\u0026lt;T\u0026gt;::return_type; task\u0026lt;T\u0026gt; get_return_object() noexcept { task\u0026lt;T\u0026gt; task(coro::coroutine_handle\u0026lt;task_promise\u0026gt;::from_promise(*this)); ret_ = task.ret_value_ = std::make_shared\u0026lt;task_return_type\u0026gt;(); // 保存task的ret_value_指针  return task; } void return_value(T value) { LOG_DEBUG(\u0026#34;return_value: {}\u0026#34;, value); *ret_ = value; } std::shared_ptr\u0026lt;typename task\u0026lt;T\u0026gt;::return_type\u0026gt; ret_; }; 这里需要注意的是get_return_object()方法的返回值是固定的，不能是指针或引用类型，所以我们不能通过保存task指针或引用的方式将结果保存到task对象中，因为在get_return_object()函数创建的是临时对象，同样在task中的ret_value_也只能是指针类型，不然你设置的只能是临时对象的值。\n推迟promose_type对象的析构时间。还记得 promose_type 中 final_suspend 方法吗？ 会看前面的展开式：  auto ret = ...; p-\u0026gt;return_value(ret); goto __final_suspend_point; __final_suspend_point: co_await p-\u0026gt;final_suspend(); // 可以通过这步暂停后面销毁操作的执行  __destroy_point: promise_type::operator delete(frame, sizeof(frame_type)); 可以看到在协程函数调用 promose_type 析构函数（实际上析构的是协程帧）前 co_await 了 final_suspend 的返回结果。所以我们可以利用这点，来实现 promose_type 析构的推迟。如下面的代码：\ntemplate\u0026lt;typename T\u0026gt; class task { ~task() { // 外部对象析构时才真正销毁协程帧 \th_coro_.destory(); } struct promise_type { auto final_suspend() noexcept { return std::suspend_always{}; } } ... std::coroutine_handle\u0026lt;promise_type\u0026gt; h_coro_; } 注意，理论上 co_await final_suspend() 后应该能够通过 coroutine_handle 的 resume 方法恢复然后继续执行析构操作，但是无论是 visual studio 还是 gcc 这样操作都会导致异常，目前还不清楚原因。所以只能在外部对象task的析构函数中主动调用destory方法去完成析构任务。\n在实际的使用中我还是选择了第一种方案，因为第一种更符合“职责单一”的原则，task负责外部数据的生命周期，promise负责协程内部资源的生命周期，另外由于第一种方案更“及时”的释放协程帧资源，所以内存使用率更高效。\n使用协程对hiredis进行封装 C++ 协程的概念虽多，但是经过前面的分析，我们可以对其进行整理将不易变动的部分提取出来（见coro_task.h）。使用coro_task.h中代码，我们可以套用同一套代码来实现不同的协程功能。对于task及其promise_type在我们定义后基本不会在变动它们，而需要变动的是task_awaiter的await_suspend两个函数已经被提取为构造函数的两个回调参数。\n对于hiredis的异步调用接口封装，只需在task_awaiter的suspend_callback中添加命令调用的代码，然后在resume_callback处理回调结果便可以了，可以参考reids_client中coro_command的代码。其实coro_task不单单对于hiredis是有效的，对于大多数需要回调函数的调用都不要修改代码。\n在coro_command代码中一个有意思的地方是，suspend_callback中redisAsyncFormattedCommand异步调用的结果怎样传给resume_callback。一开始我的想法是暂存在promise_type对象中，因为可以通过await_suspend的协程句柄参数可以方便的得到promise_type对象，另一方面promise_type的生命周期是到整个协程调用结束，暂存在这里比较安全。但是有个问题，我们先看下await_suspend的协程句柄参数的声明：\ncoro::coroutine_handle\u0026lt;task_promise\u0026lt;TASK_RET\u0026gt;\u0026gt; 在这里我们必须要知道task的模版参数TASK_RET，这样其实没什么大问题，但是有个不方便的地方是我们在构造task_awaiter的时候就需要两个模版参数（co_await返回值类型CORO_RET和协程函数返回值类型TASK_RET，代码可参考examples/301）。如果每次调用都带上这两个参数还是挺麻烦的。CORO_RET还好，我们在封装redis的每个命令时已经知道了其返回类型，可以对其特化，如下面的代码：\ntemplate\u0026lt;typename TASK_RET\u0026gt; task_awaiter\u0026lt;TASK_RET, std::string\u0026gt; coro_echo(std::string_view msg) { return coro_command\u0026lt;TASK_RET, std::string\u0026gt;(fmt::format(\u0026#34;echo {}\u0026#34;, msg)); } 但是TASK_RET便比较讨厌了，只有在调用的时候才能知道，如果按现在的方案就需要写下如下的代码：\ntask\u0026lt;int\u0026gt; watchdog::coro_call_test() { auto r = co_await redis_client::get().coro_echo\u0026lt;int\u0026gt;(\u0026#34;test\u0026#34;); auto var1 =co_await redis_client::get().coro_incr\u0026lt;int\u0026gt;(\u0026#34;var1\u0026#34;); auto var2 = co_await redis_client::get().coro_incr\u0026lt;int\u0026gt;(\u0026#34;var2\u0026#34;); auto var3 = std::to_string(var1.value() + var2.value\u0026lt;int\u0026gt;()); co_await redis_client::get().coro_set\u0026lt;int\u0026gt;(\u0026#34;var3\u0026#34;, var3); auto var3_2 = co_await redis_client::get().coro_get\u0026lt;int\u0026gt;(\u0026#34;var3\u0026#34;); LOG_DEBUG(\u0026#34;r: {}, var1: {}, var2: {}, var3: {}, var3_2: {}\u0026#34;, r.value(), var1.value(), var2.value(), var3, var3_2.value()); co_return 1; } 每个coro_*命令都要带上与task\u0026lt;T\u0026gt;一样的模版参数。有什么办法解决这个烦恼呢？让我们先看下coro::coroutine_handle\u0026lt;T\u0026gt;的定义：\ntemplate \u0026lt;class = void\u0026gt; struct coroutine_handle; 他有两种特化：\n 不可访问promise  template \u0026lt;\u0026gt; struct coroutine_handle\u0026lt;void\u0026gt;{...} 可访问promise  template \u0026lt;class _Promise\u0026gt; struct coroutine_handle {...} 所以如果我们想使用不带模版参数的版本就无法访问promise，一旦我们无法访问promise，那么redis的异步调用结果可以放哪里呢？让我们回到suspend_callback和resume_callback定义的地方，能暂存在task_awaiter对象中吗？让我们再次分析下协程展开式：\ntry { auto retm, retn, ...; // co_await std::experimental::suspend_always{}; \t{ auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m; \tif (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp \t} } resume_label_m: retm = tmp.await_resume(); } ... 虽然协程表达式是临时变量但是它并不会因为协程暂停而销毁，所以将异步结果存放在协程表达式中更符合我们的预期，而且一旦await_resume调用结束临时对象变被销毁，这样内存利用率更高。\n既然可行，我们就对task_awaiter进行改造吧，先添加set_coro_return方法，然后在suspend_callback和resume_callback方法中添加task_awaiter指针参数，最后去掉task_awaiter的模版参数TASK_RET。经过改造task和task_awaiter都只需要关心与自己相关的模版参数，两者再无瓜葛。终于可以像下面的代码那样愉快的调用了：\ntask\u0026lt;bool\u0026gt; watchdog::coro_call_test() { auto r = co_await redis_client::get().coro_echo(\u0026#34;test\u0026#34;); auto var1 =co_await redis_client::get().coro_incr(\u0026#34;var1\u0026#34;); auto var2 = co_await redis_client::get().coro_incr(\u0026#34;var2\u0026#34;); auto var3 = std::to_string(var1.value() + var2.value()); co_await redis_client::get().coro_set(\u0026#34;var3\u0026#34;, var3); auto var3_2 = co_await redis_client::get().coro_get(\u0026#34;var3\u0026#34;); LOG_DEBUG(\u0026#34;r: {}, var1: {}, var2: {}, var3: {}, var3_2: {}\u0026#34;, r.value(), var1.value(), var2.value(), var3, var3_2.value()); co_return true; } 自此hiredis协程的封装工作已经结束了，剩下的就是针对redis的各种命令进行特化处理。\n","date":"August 18, 2021","hero":"/posts/c++/coro_redis/coro_redis.jpg","permalink":"https://gqw.gitee.io/posts/c++/coro_redis/","summary":"本文是coro_redis项目的开发手记，其较为详尽的描述了其开发过程中遇到的问题和解决方案以及学习心得。希望能和大家共同努力和完善此项目。项目地址为： https://github.com/gqw/coro_redis\n自从上次写完《从HelloWold开始，深入浅出C++ 20 Coroutine TS》已经有一阵子没有写C++代码了，在那篇文章中给自己立了FLAG说要继续写一篇关于asio中使用协程开发的文章也一直没有兑现。现在趁着空闲用协程写了一个redis client库。\n代码还是像mrpc一样追求少而精，希望大家能够学会怎样使用c++的协程，而不是直接把库拿过去用。\n协程是从C++20开始被加进标准库的，但是仅支持基本的协程功能，用起来还不是很方便，估计需要等到C++23才能完善（请参考：C++23的目标）。VisualStudio 2022 PREVIEW（ToolSet v143）已经正式支持协程，相关头文件也已经从experimental目录移到正式目录，并且不需再添加 /await 编译选项（v143之前使用协程请参考/await选项说明）。GCC从10.0版本开始支持协程，11.0版本不再是experimental，但还是需要 -fcoroutines 编译选项（请参考：C++ Standards Support in GCC）。\n以下是开发使用的环境：\n   windows linux     Windows 10 版本 2004 Ubuntu 20.04.2 LTS(wsl2)   Visual Studio 2022(v143) GCC 11.1.0   cmake version 3.21.1 cmake version 3.21.1   Vcpkg version 2021-07-26-9425cf5f512f242c0bcbabac31f08832825aee81 Same as Windows    编译说明  安装vcpkg 设置并导出环境变量 VCPKG_ROOT 为 vcpkg 根目录 如果再Winodws下开发，由于Visual Studio还是预览版，vcpkg默认不会使用，所有需要在%VCPKG_ROOT%/triplets目录下添加x86-windows-v143.","tags":null,"title":"coro_redis 开发手记"},{"categories":null,"contents":"# 下载，解压 tar -xf gcc-11.1.0.tar.xz cd gcc-11.1.0.tar # 安装必要编译工具 sudo apt install gcc g++ make # 安装依赖库 sudo apt install libgmp-dev # 生成makefile文件 ./configure # 编译安装 make -j 10 sudo make install ","date":"July 30, 2021","hero":"/posts/c++/build_gcc/gnu-gcc.jpg","permalink":"https://gqw.gitee.io/posts/c++/build_gcc/","summary":"# 下载，解压 tar -xf gcc-11.1.0.tar.xz cd gcc-11.1.0.tar # 安装必要编译工具 sudo apt install gcc g++ make # 安装依赖库 sudo apt install libgmp-dev # 生成makefile文件 ./configure # 编译安装 make -j 10 sudo make install ","tags":null,"title":"Linux 编译GCC 11"},{"categories":null,"contents":"问题 这两天在整理博客，一直使用GitHub和Gitee的Pages功能作为博客的静态托管站。但是遇到以下几个问题：\n 每次PUSH都要向两个网站分别提交，操作繁琐 域名问题， 博客使用的Hugo博客生成系统，根域名是在config.yaml配置的，导致最终的域名管理比较混乱。比如配置了github的域名，提交给gitee时忘记改，就会导致某些图片或内容访问不稳定。 Gitee发布比较麻烦，需要手动更新提交  解决方法   对于多次提交的问题，最初解决方法是使用以下命令：\n$ git remote set-url --add origin git@github.com:gqw/gqw.github.io.git $ git remote -v origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) origin git@github.com:gqw/gqw.github.io.git (push) 方法解决。添加过后每次提交都会同时往两个仓库提交。\n但是为了解决第二个问题，即不同域名问题，最终并未使用此方案。\n  解决不同域名问题，解决思路是通过git hook在提交和上次时在hook脚本里修改Hugo生成好的内容。\n 首先准备好远程url  $ git remote -v github_auto_change_domian git@github.com:gqw/gqw.github.io.git (fetch) github_auto_change_domian git@github.com:gqw/gqw.github.io.git (push) origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) 然后在仓库的.git/hooks目录中添加commit-msg文件，内容为：  commit_msg=$(cat $1) echo $commit_msg if [[ $commit_msg =~ \u0026#34;replace domain to github\u0026#34; ]]; then # 向github上传前会修改仓库内容，并做一次提交记录， # 这时不需要重新生成文档 echo \u0026#34;replace domain to github\u0026#34; else # 清空生成目录内容 rm -rfv ./docs/* # 重新生成 hugo # 复制一些固定内容 cp -v ./static/search_engine/* ./docs/ git add ./ fi exit 0 这样每次执行git commit时都会更新站点内容，保证每次提交内容都是最新的。\n在仓库的.git/hooks目录中添加pre-push文件，内容为：  remote=\u0026#34;$1\u0026#34; url=\u0026#34;$2\u0026#34; # 如果remote为 github_auto_change_domian 将跳过处理，否则会死循环， # 因为下面调用了git push 指令 if [ \u0026#34;$remote\u0026#34; == \u0026#34;origin\u0026#34; ];then # 修改域名 git ls-tree -r source --name-only | grep -E \u0026#34;docs/.*\\.html\u0026#34; | xargs sed -i \u0026#39;s/gqw\\.gitee/gqw\\.github/g\u0026#39; # 提交修改 git commit -a -s -m \u0026#34;replace domain to github\u0026#34; # 上传到giithub git push github_auto_change_domian echo \u0026#34;upload to github end\u0026#34; fi exit 0 至此上传和域名问题解决。\n  Gitee发布问题是通过网上别人提供的github action解决的。 在 .github/workflows 目录下添加任意*.yaml文件，内容如下：\nname: Deploy to Github Pages # run when a commit is pushed to \u0026#34;source\u0026#34; branch on: push: branches: - source jobs: deploy: runs-on: ubuntu-18.04 steps: - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: gqw # 注意在 Settings-\u0026gt;Secrets 配置 GITEE_PASSWORD gitee-password: ${{ secrets.GITEE_PASSWORD }} # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: gqw/gqw # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: source directory: docs https: true 此action其实只是通过python模拟登陆然后模拟用户提交更新请求。 具体使用请参考原文说明yanglbme/gitee-pages-action\n  总结 好了，遇到的问题现在都处理好了， 这样在每次commit是便会自动更新站点内容，push时会自动处理域名并向两个网站分别push, 最后还自动完成了gitee的站点更新。\n","date":"July 28, 2021","hero":"/posts/git/sync_github_gitee/imgs/github_gitee.jpg","permalink":"https://gqw.gitee.io/posts/git/sync_github_gitee/","summary":"问题 这两天在整理博客，一直使用GitHub和Gitee的Pages功能作为博客的静态托管站。但是遇到以下几个问题：\n 每次PUSH都要向两个网站分别提交，操作繁琐 域名问题， 博客使用的Hugo博客生成系统，根域名是在config.yaml配置的，导致最终的域名管理比较混乱。比如配置了github的域名，提交给gitee时忘记改，就会导致某些图片或内容访问不稳定。 Gitee发布比较麻烦，需要手动更新提交  解决方法   对于多次提交的问题，最初解决方法是使用以下命令：\n$ git remote set-url --add origin git@github.com:gqw/gqw.github.io.git $ git remote -v origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) origin git@github.com:gqw/gqw.github.io.git (push) 方法解决。添加过后每次提交都会同时往两个仓库提交。\n但是为了解决第二个问题，即不同域名问题，最终并未使用此方案。\n  解决不同域名问题，解决思路是通过git hook在提交和上次时在hook脚本里修改Hugo生成好的内容。\n 首先准备好远程url  $ git remote -v github_auto_change_domian git@github.com:gqw/gqw.github.io.git (fetch) github_auto_change_domian git@github.com:gqw/gqw.github.io.git (push) origin git@gitee.com:gqw/gqw.git (fetch) origin git@gitee.com:gqw/gqw.git (push) 然后在仓库的.git/hooks目录中添加commit-msg文件，内容为：  commit_msg=$(cat $1) echo $commit_msg if [[ $commit_msg =~ \u0026#34;replace domain to github\u0026#34; ]]; then # 向github上传前会修改仓库内容，并做一次提交记录， # 这时不需要重新生成文档 echo \u0026#34;replace domain to github\u0026#34; else # 清空生成目录内容 rm -rfv .","tags":null,"title":"同步GitHub pages和 Gitee pages方法"},{"categories":null,"contents":"缘由与目标 随着计算机硬件的发展，游戏的玩法和画质也得到了飞速的发展。游戏内容越来越丰富，画面质量也越来越精细。这也导致了游戏的包体越来越大。PC端游戏基本上10GB起步，《战地》，《易水寒》等游戏基本已经达到100G体量。如此大的体量对于游戏发行方，是一个必须要考虑的问题。用于游戏分发的下载器我们必须考虑以下几个方面：\n1. 可访问， 这是下载器的首要前提，我们必须保证数据能够被联网的任意玩家可以访问到。\r2. 数据可靠，下载的资源必须是正确的内容。\r3. 速度，我们必须尽可能的保证玩家的下载速度。\r4. 稳定，需要能够稳定下载所需资源。\r5. 节省流量，虽然这是个可选项但是流量就意味着金钱，所以下载器还需要尽可能的节约流量。\r 通常的下载器使用的是Http方式下载，虽然能够保证可靠地数据访问，但是离高速稳定省流量还有较大差距，为了提高速度和稳定性我们通过使用CDN的方案有效解决。但是CDN解决不了节省流量的目标（实际上是增加流量成本的）， 简单的解决方法是使用压缩下载内容，目前项目中使用的下载器就是使用的这种方法。压缩数据的方法效果还是非常有效的，以某款为例，12GB的包可以压缩到7GB, 也就是可以节省40%的流量。\n是否可以有更有效的方法解决流量问题呢？很自然的想法是使用P2P加速技术。P2P是指 peer to peer, 即节点到节点数据传输，就是各个客户端之间数据传输。大家常见的P2P技术主要是BT下载技术，但是BT与我们前面使用的技术是由冲突的。我们先看下HTTP与BT的结构图进行简单的对比下：\nHTTP下载方式\r\rBT下载方式\r\r\r对比可知， HTTP是基于C/S架构的，客户机是严格依赖中心服务器的，BT无中心节点所有数据都是玩家之间传输。HTTP的好处是访问可控，只要客户机能连接到服务器就肯定能获得所需数据，但是服务器必须承担所有流量压力和流量费用。 BT的好处也是显而易见的，所有数据传输都是玩家之间的行为，甚至可以不需要部署服务器，服务器的压力和费用为零，但是BT却有可能违背我们前面所述下载的最基本要求——可访问，玩家节点的连接并不能像HTTP那样是可靠稳定的。\n有没有可能结合HTTP和BT技术，充分利用各自的优势并互相弥补对方的缺点呢？实现如下的结构：\nP2SP下载方式\r\r\r幸运的是答案为YES, 迅雷的P2SP技术就是基于上述思想实现的，说明技术方向是对的，不用再去怀疑和验证技术的可行性。但是需要注意的是，迅雷的P2S我们的需求是有差异的， 迅雷下载器P2S部分的S并不是自己的服务器（而是各个下载站点的服务器），所以它不用考虑这部分的流量压力和费用，而我们作为内容提供方流量和费用必须自己承担。所以迅雷并不关心用户数据是否压缩，但是对于我们内容提供商就必须要考虑通过前面压缩技术获得的40%的利益。\n看到这里你可能会想，压缩还不容易吗？直接用压缩软件把下载内容打包下上传到HTTP服务器不就行了吗？是的如果不考虑BT文件的分享率，这样做是解决了问题，但这意味着我们BT分享的内容也是个压缩包，因为我们业务是游戏启动器，也就是说我们不可能将用户下载的游戏安装包一直保留，举个例子，如果我们的游戏原始文件为100GB压缩后为60GB，如果按刚才的方案，用户下载60GB的安装包后，再解压为100GB的原始文件，也就是说必须占用用户160GB的磁盘空间，而这其中的60GB只是为了方便他人下载用的。\n如果在用户安装完游戏后再将安装包删除，那此用户通过BT分享的时间也就只有其下载+安装的时间了。如何解决这个矛盾呢？ 我们现在梳理下问题：\n 通过HTTP下载的内容需要时压缩的数据 通过BT分享的内容必须是原始的内容  通过分析我们可以发现看似不可调和矛盾其实是有解的。那就是需要在下载的时候将HTTP压缩数据原地解压。自此方案的的思路已经基本清晰，但还有一个需要考虑的问题，根据BT的协议标准，BT下载时是将所有数据拼成一个数据块，再将这个数据块进行切块下载的。这就导致一个问题，通常我们压缩数据是按照文件为单位进行压缩的，但是BT下载时是按照切块进行下载的，这会导致HTTP和BT下载内容对应不上，如下图：\nZIP格式\r\r\rBT格式\r\r\rBT的下载原理是根据上图将需要下载的内容先按照文件进行拼接再进行切片（Piece），建立多个下载通道，每个通道根据切片的状态选择下载并更新切片状态。在下载时BT将无视文件的概念，对于BT来说每次下载只是一片连续的数据块。这样如果HTTP按照文件从压缩包中提取数据，下载后将很难找到对应的BT文件中Piece的位移，也就无法更新下载Piece的状态。\n解决思路是，反过来我们在数据压缩时不再以文件为单位进行压缩，而是按照BT的Piece为单位创建压缩文件，并记录每个Piece在压缩文件中的位移。HTTP下载通道下载时先向BT模块申请需要下载的Piece，再根据Piece的位移从HTTP服务器下载相应内容，最后更新BT Piece状态。\n具体实施 准备阶段  创建种子文件（.torent） 根据种子文件中piece length创建压缩文件 修改种子文件添加peice的压缩信息，主要是每个piece压缩后大小和总压缩文件大小。可以根据piece压缩后大写算出每个piece的偏移量 上传压缩文件到CDN 修改种子文件添加CDN中压缩文件HTTP下载地址 上传种子文件到CDN  实际处理中1,2,3,5步骤可以通过修改torrent文件合并处理。\n下载阶段 修改BT下载器，根据torrent文件中的的压缩文件地址建立特殊下载通道，模拟BT请求下载块，根据BT文件中的压缩块大小计算Piece在压缩文件中的偏移，使用HTTP Range Requests标准下载对应的数据块，下载完后更新对应Piece状态。直至所有文件下载完成。\n相关工程 libtorrent\n","date":"July 27, 2021","hero":"/posts/net/p2p/imgs/hero.jpg","permalink":"https://gqw.gitee.io/posts/net/p2p/","summary":"缘由与目标 随着计算机硬件的发展，游戏的玩法和画质也得到了飞速的发展。游戏内容越来越丰富，画面质量也越来越精细。这也导致了游戏的包体越来越大。PC端游戏基本上10GB起步，《战地》，《易水寒》等游戏基本已经达到100G体量。如此大的体量对于游戏发行方，是一个必须要考虑的问题。用于游戏分发的下载器我们必须考虑以下几个方面：\n1. 可访问， 这是下载器的首要前提，我们必须保证数据能够被联网的任意玩家可以访问到。\r2. 数据可靠，下载的资源必须是正确的内容。\r3. 速度，我们必须尽可能的保证玩家的下载速度。\r4. 稳定，需要能够稳定下载所需资源。\r5. 节省流量，虽然这是个可选项但是流量就意味着金钱，所以下载器还需要尽可能的节约流量。\r 通常的下载器使用的是Http方式下载，虽然能够保证可靠地数据访问，但是离高速稳定省流量还有较大差距，为了提高速度和稳定性我们通过使用CDN的方案有效解决。但是CDN解决不了节省流量的目标（实际上是增加流量成本的）， 简单的解决方法是使用压缩下载内容，目前项目中使用的下载器就是使用的这种方法。压缩数据的方法效果还是非常有效的，以某款为例，12GB的包可以压缩到7GB, 也就是可以节省40%的流量。\n是否可以有更有效的方法解决流量问题呢？很自然的想法是使用P2P加速技术。P2P是指 peer to peer, 即节点到节点数据传输，就是各个客户端之间数据传输。大家常见的P2P技术主要是BT下载技术，但是BT与我们前面使用的技术是由冲突的。我们先看下HTTP与BT的结构图进行简单的对比下：\nHTTP下载方式\r\rBT下载方式\r\r\r对比可知， HTTP是基于C/S架构的，客户机是严格依赖中心服务器的，BT无中心节点所有数据都是玩家之间传输。HTTP的好处是访问可控，只要客户机能连接到服务器就肯定能获得所需数据，但是服务器必须承担所有流量压力和流量费用。 BT的好处也是显而易见的，所有数据传输都是玩家之间的行为，甚至可以不需要部署服务器，服务器的压力和费用为零，但是BT却有可能违背我们前面所述下载的最基本要求——可访问，玩家节点的连接并不能像HTTP那样是可靠稳定的。\n有没有可能结合HTTP和BT技术，充分利用各自的优势并互相弥补对方的缺点呢？实现如下的结构：\nP2SP下载方式\r\r\r幸运的是答案为YES, 迅雷的P2SP技术就是基于上述思想实现的，说明技术方向是对的，不用再去怀疑和验证技术的可行性。但是需要注意的是，迅雷的P2S我们的需求是有差异的， 迅雷下载器P2S部分的S并不是自己的服务器（而是各个下载站点的服务器），所以它不用考虑这部分的流量压力和费用，而我们作为内容提供方流量和费用必须自己承担。所以迅雷并不关心用户数据是否压缩，但是对于我们内容提供商就必须要考虑通过前面压缩技术获得的40%的利益。\n看到这里你可能会想，压缩还不容易吗？直接用压缩软件把下载内容打包下上传到HTTP服务器不就行了吗？是的如果不考虑BT文件的分享率，这样做是解决了问题，但这意味着我们BT分享的内容也是个压缩包，因为我们业务是游戏启动器，也就是说我们不可能将用户下载的游戏安装包一直保留，举个例子，如果我们的游戏原始文件为100GB压缩后为60GB，如果按刚才的方案，用户下载60GB的安装包后，再解压为100GB的原始文件，也就是说必须占用用户160GB的磁盘空间，而这其中的60GB只是为了方便他人下载用的。\n如果在用户安装完游戏后再将安装包删除，那此用户通过BT分享的时间也就只有其下载+安装的时间了。如何解决这个矛盾呢？ 我们现在梳理下问题：\n 通过HTTP下载的内容需要时压缩的数据 通过BT分享的内容必须是原始的内容  通过分析我们可以发现看似不可调和矛盾其实是有解的。那就是需要在下载的时候将HTTP压缩数据原地解压。自此方案的的思路已经基本清晰，但还有一个需要考虑的问题，根据BT的协议标准，BT下载时是将所有数据拼成一个数据块，再将这个数据块进行切块下载的。这就导致一个问题，通常我们压缩数据是按照文件为单位进行压缩的，但是BT下载时是按照切块进行下载的，这会导致HTTP和BT下载内容对应不上，如下图：\nZIP格式\r\r\rBT格式\r\r\rBT的下载原理是根据上图将需要下载的内容先按照文件进行拼接再进行切片（Piece），建立多个下载通道，每个通道根据切片的状态选择下载并更新切片状态。在下载时BT将无视文件的概念，对于BT来说每次下载只是一片连续的数据块。这样如果HTTP按照文件从压缩包中提取数据，下载后将很难找到对应的BT文件中Piece的位移，也就无法更新下载Piece的状态。\n解决思路是，反过来我们在数据压缩时不再以文件为单位进行压缩，而是按照BT的Piece为单位创建压缩文件，并记录每个Piece在压缩文件中的位移。HTTP下载通道下载时先向BT模块申请需要下载的Piece，再根据Piece的位移从HTTP服务器下载相应内容，最后更新BT Piece状态。\n具体实施 准备阶段  创建种子文件（.torent） 根据种子文件中piece length创建压缩文件 修改种子文件添加peice的压缩信息，主要是每个piece压缩后大小和总压缩文件大小。可以根据piece压缩后大写算出每个piece的偏移量 上传压缩文件到CDN 修改种子文件添加CDN中压缩文件HTTP下载地址 上传种子文件到CDN  实际处理中1,2,3,5步骤可以通过修改torrent文件合并处理。\n下载阶段 修改BT下载器，根据torrent文件中的的压缩文件地址建立特殊下载通道，模拟BT请求下载块，根据BT文件中的压缩块大小计算Piece在压缩文件中的偏移，使用HTTP Range Requests标准下载对应的数据块，下载完后更新对应Piece状态。直至所有文件下载完成。","tags":null,"title":"一种简单可行的P2SP实践方案"},{"categories":null,"contents":"tcprt 介绍  产品发布后有玩家反映客户端（Windows系统）无法连接服务器， 使用ping.exe、tracert.exe工具检查均未发现有异常情况，但是telnet却无法连接。最后发现发现国内某些运营商网络在对icmp和tcp协议的路由选择上不一致导致。最后运维人员希望能够收集出错时的路由信息。 我们知道在Linux系统上实现很简单系统自带的traceroute工具自带tcp协议的探测，实现起来比较简单。但是客户端产品大多是Windows系统的，自带的tracert.exe只有icmp探测类型。下图是分别使用ICMP和TCPtracerouter的对比，图中可以看到明显的不同路由路径。 目标   实现类似于linux的traceroute -T方法  原理与实现  tracerouter原理  为了理解tracerouter原理，我们先来看下IP的协议头： 这里面有个8比特的Time To Live (TTL)字段，它代表是报文的存活时间，这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份ICMP报文被发回报文发送端说明其发送的报文已被丢弃。这也是traceroute的核心原理。 什么意思呢？我们看下下面的图： 这里表示的是192.168.1.2这台客户机访问192.168.5.32的路由图，报文首先在客户机（1.2）这台机器被创建出来并设置TTL字段为128, 然后经过若干路由接力传递最终到达目标服务器，在接力过程中没遇到一个路由中转，路由器均会将TTL值减一。再看这张图： 这次我们在客户机组装报文时将TTL设置的比较小只有3，这样在报文到达第一个路由路时路由检查报文中TTL的值发现TTL大于1于是修改报文将TTL减1继续转发给下一个路由，第二个路由采用同样的方法修改TTL后继续发给第三个路由，第三个路由受到报文时同样检查TTL值，发现TTL值已经为1，意识到自己已经是最后一跳不能再继续转发了，所以直接向源主机发送类型为11的ICMP报文告诉源主机报文发送失败（当然返回的报文也需要若干路由跳转，图中返回的虚箭头指示表达报文最终到达源主机）。\ntraceroute为了探测每个路由的地址，循环递增报文的TTL值，当TTL等于1时第一个路由便返回ICMP报文，源机器便可根据其IP头获得路由地址，当TTL等于2时可以得到第二个路由地址，依次循环下去直到到达目标机器。\n实现  tracert在Windows下只有基于ICMP协议的实现。Linux下倒是有TCP版本的实现，\ntraceroute -T www.baidu.com 80 既然如此那就看看源码，借鉴下别人是怎么实现的。Linux下traceroute[3]的思路比较直接，使用原始套接字（SOCK_RAW）向目的主机发送tcp连接, 并递增请求包的TTL值，再用recvmsg中flags设置MSG_ERRQUEUE选项来获取连接信息。\n但是在Windows系统下就没有那么幸运了。系统为了安全考虑（主要怕原始套接字被滥用）禁止了以下行为[1]：\n  TCP data cannot be sent over raw sockets.\n  A call to the bind function with a raw socket for the IPPROTO_TCP protocol is not allowed.\n  而且recvmsg也没有MSG_ERRQUEUE可以使用。所以直接照搬Linux下traceroute的想法没法设施。\n既然系统把路堵住了，有没有办法绕开去呢？其实是有的，在微软的文档中提到[1]：\n On Windows Server 2003 and earlier, a Transport Driver Interface (TDI) provider and a Winsock helper DLL can be written to support the network protocol. The network protocol would then be added to the Winsock catalog as a supported protocol. This allows multiple applications to open sockets for this specific protocol and the device driver can keep track of which socket receives specific packets and errors.\n 也就是需要你自己开发个驱动。好在有人已经实现了这样的功能，winpcap便是这样的网络库，也有人基于此开发了Windows下基于tcp协议的traceroute[2]。但是为了这么一个简单的功能开发让用户安装如此危险的驱动程序，对用户来说是十分不友好的（winpcap静默安装是收费功能）。\n还有其它方法吗？让我们回过头来仔细分析下思路。我们想要探测只需要每次发送的网络包中的ttl逐渐增大便可以了。系统限制了我们直接组装TCP网络包的能力，我们能否利用现有的资源呢？\n 我们正常建立TCP连接总还是可以的，只是我们有手段修改其TTL的值吗？ 幸运的是可以的。(Lucky + 1) 发送的数据有了，接收有吗？TTL值为0时路由会返回ICMP包吗？ 同自己组装的效果一样，也是有的。(Lucky + 1) 我们没有MSG_ERRQUEUE，可以获得响应内容吗？ 回答是Yes。 (Lucky + 1)  有了上面的3个幸运值，我们就可以实现我们的目的了，思路如下：\n 建立正常的TCP套接字进行connect连接，不过调用前通过修改socket选项修改TTL值。 另外再建立个原始套接字，监听所有响应。 收到任何响应关闭TCP套接字。  实现细节参考代码。\n下面说下实现时的一些注意点：\n 修改TTL方法： setsockopt (tcp_sk, IPPROTO_IP, IP_TTL, (char*)\u0026amp;ttl, sizeof (ttl))  设置连接socket为非阻塞模式，这样connect后可以立即监听网络响应。 因为是并发请求所以需要在connect之前bind一下，这样可以在探测结束前一直占用一个本地端口号，后面也可以根据这个端口进行信息匹配。 监听的原始套接字通过下面代码创建： socket(AF_INET, SOCK_RAW, IPPROTO_IP)  原始套接字需要打开 SIO_RCVALL 选项，这样才能收到所有网络包，包括connect连接成功后的syn+ack包。 打开 SIO_RCVALL 选项需要先进行bind操作才可以，不然会报10022错误。 因为打开了 SIO_RCVALL 所以每个探测线程会收到bind地址的所有网络包，所以要根据协议头进行过滤和区分。前面占用的本地端口是探测线程的一个重要依据。  优势与不足  优势  并发探测，探测时间与ttl值无关，速度相对于windows系统自带命令快N倍。 代码精简（不到500行代码），不依赖任何第三方库。  缺点  由于使用原始套接字（SOCK_RAW）代码执行需要管理员权限。 由于并发请求，无法做到及时停止探测，会造成很多无用的探测。  使用  git clone https://github.com/gqw/tcprt.git cd tcprt mkdir build cd build cmake .. ./tcprt.exe 180.101.49.11 80 30\r计划内容   支持ipv6 支持域名解析  参考文献 [1] TCP/IP Raw Sockets[EB/OL]. https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2\n[2] tracetcp[EB/OL]. https://github.com/0xcafed00d/tracetcp\n[3] traceroute[EB/OL]. http://ftp.oregonstate.edu/.2/lfs-website/blfs/view/svn/basicnet/traceroute.html\n","date":"December 29, 2020","hero":"/posts/net/tcptrace/images/forest.jpg","permalink":"https://gqw.gitee.io/posts/net/tcptrace/","summary":"tcprt 介绍  产品发布后有玩家反映客户端（Windows系统）无法连接服务器， 使用ping.exe、tracert.exe工具检查均未发现有异常情况，但是telnet却无法连接。最后发现发现国内某些运营商网络在对icmp和tcp协议的路由选择上不一致导致。最后运维人员希望能够收集出错时的路由信息。 我们知道在Linux系统上实现很简单系统自带的traceroute工具自带tcp协议的探测，实现起来比较简单。但是客户端产品大多是Windows系统的，自带的tracert.exe只有icmp探测类型。下图是分别使用ICMP和TCPtracerouter的对比，图中可以看到明显的不同路由路径。 目标   实现类似于linux的traceroute -T方法  原理与实现  tracerouter原理  为了理解tracerouter原理，我们先来看下IP的协议头： 这里面有个8比特的Time To Live (TTL)字段，它代表是报文的存活时间，这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份ICMP报文被发回报文发送端说明其发送的报文已被丢弃。这也是traceroute的核心原理。 什么意思呢？我们看下下面的图： 这里表示的是192.168.1.2这台客户机访问192.168.5.32的路由图，报文首先在客户机（1.2）这台机器被创建出来并设置TTL字段为128, 然后经过若干路由接力传递最终到达目标服务器，在接力过程中没遇到一个路由中转，路由器均会将TTL值减一。再看这张图： 这次我们在客户机组装报文时将TTL设置的比较小只有3，这样在报文到达第一个路由路时路由检查报文中TTL的值发现TTL大于1于是修改报文将TTL减1继续转发给下一个路由，第二个路由采用同样的方法修改TTL后继续发给第三个路由，第三个路由受到报文时同样检查TTL值，发现TTL值已经为1，意识到自己已经是最后一跳不能再继续转发了，所以直接向源主机发送类型为11的ICMP报文告诉源主机报文发送失败（当然返回的报文也需要若干路由跳转，图中返回的虚箭头指示表达报文最终到达源主机）。\ntraceroute为了探测每个路由的地址，循环递增报文的TTL值，当TTL等于1时第一个路由便返回ICMP报文，源机器便可根据其IP头获得路由地址，当TTL等于2时可以得到第二个路由地址，依次循环下去直到到达目标机器。\n实现  tracert在Windows下只有基于ICMP协议的实现。Linux下倒是有TCP版本的实现，\ntraceroute -T www.baidu.com 80 既然如此那就看看源码，借鉴下别人是怎么实现的。Linux下traceroute[3]的思路比较直接，使用原始套接字（SOCK_RAW）向目的主机发送tcp连接, 并递增请求包的TTL值，再用recvmsg中flags设置MSG_ERRQUEUE选项来获取连接信息。\n但是在Windows系统下就没有那么幸运了。系统为了安全考虑（主要怕原始套接字被滥用）禁止了以下行为[1]：\n  TCP data cannot be sent over raw sockets.\n  A call to the bind function with a raw socket for the IPPROTO_TCP protocol is not allowed.\n  而且recvmsg也没有MSG_ERRQUEUE可以使用。所以直接照搬Linux下traceroute的想法没法设施。\n既然系统把路堵住了，有没有办法绕开去呢？其实是有的，在微软的文档中提到[1]：\n On Windows Server 2003 and earlier, a Transport Driver Interface (TDI) provider and a Winsock helper DLL can be written to support the network protocol.","tags":null,"title":"tcprt"},{"categories":null,"contents":"在开发时我们经常会遇到需要序列号和反序列化得操作。比如将程序配置导出下次打开再从配置中读取，通常你可以将信息保存成json、xml或ini格式，让后再解析出来。更常见的情形是我们通过网络发送和接收数据，也涉及到序列化和反序列化操作，当让你可以使用protobuf、msgpack等序列化库。但是如果你只是个简单程序，或者序列化和反序列化的业务不是很重，不想搞得那么复杂有什么简单的方法吗？\n最直接的方法 直接按字节拷贝，见代码:\n#include \u0026lt;string\u0026gt; bool encode(const std::string\u0026amp; s, int32_t a, int32_t b, int32_t c, std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); if (buf.size() \u0026lt; (sizeof(int32_t) * 4 + d)) return false; std::size_t pos = 0; memcpy(buf.data() + pos, \u0026amp;a, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;b, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;c, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;d, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, s.data(), d); return true; } bool decode(const std::string\u0026amp; buf, int32_t\u0026amp; a, int32_t\u0026amp; b, int32_t\u0026amp; c, std::string\u0026amp; out) { if (buf.size() \u0026lt; (sizeof(int32_t) * 4)) return false; std::size_t pos = 0; memcpy(\u0026amp;a, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(\u0026amp;b, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(\u0026amp;c, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); int32_t d = 0; memcpy(\u0026amp;d, buf.data() + pos, sizeof(int32_t)); pos += sizeof(int32_t); out = std::string(buf.data() + pos, d); return true; } int main() { std::string buf; buf.resize(1024); encode(\u0026#34;test\u0026#34;, 1, 2, 3, buf); std::string out; int a = 0, b = 0, c =0; decode(buf, a, b, c, out); return 0; } 或者简单封装下：\nstruct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { ... } bool decode(const std::string\u0026amp; buf) { ... } }; TestData in{ 1, 2, 3, \u0026#34;test\u0026#34; }; std::string buf; buf.resize(1024); in.encode(buf); TestData out; out.decode(buf); 使用stringstream 可以看到上面的代码还是比较繁琐的，不仅需要手动计算字符索引位置，还要直接使用memcpy函数。对于这个问题c++的stringstream可以简化不少代码：\nstruct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); std::ostringstream ss; ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; buf = ss.str(); return ss.good(); } bool decode(const std::string\u0026amp; buf) { std::istringstream ss(buf); int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; 可以明显的看出代码比前面的要简洁优雅多了，但是这里面却有个比较严重的问题，无论是encode还是decode都需要构建stringstream，而stringstream会在内部构建一个新的streambuf对象，无论是输入还是输出都需要一次拷贝操作。\n我们还有strstream struct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); std::ostrstream ss(buf.data(), buf.length()); ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; return ss.good(); } bool decode(const std::string\u0026amp; buf) { std::istrstream ss((char*)buf.data(), buf.length()); ss.seekp(buf.length()); // 设置写入位置（写入位置\u0026gt;读取位置才代表有数据可读）  int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; stringstream使用的人比较多，但是知道strstream的就少的多了。strstream可以使用已有的内存做rdbuf, 但是很不幸的是这么好用的工具竟然被c++标准给废弃了[1][2]。\n最后大招，自己造轮子 struct serialization_streambuf : public std::streambuf { serialization_streambuf(char* s, std::size_t n) { setp(s, s, s + n); // set write buffer pointer \tsetg(s, s, s + n); // set read buffer pointer \t} }; struct TestData { int32_t a =0; int32_t b = 0; int32_t c = 0; std::string s; bool encode(std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); serialization_streambuf osrb(buf.data(), buf.length()); std::ostream ss(\u0026amp;osrb); ss.write((const char*)\u0026amp;a, sizeof(a)); ss.write((const char*)\u0026amp;b, sizeof(b)); ss.write((const char*)\u0026amp;c, sizeof(c)); ss.write((const char*)\u0026amp;d, sizeof(d)); ss \u0026lt;\u0026lt; s; return ss.good(); } bool decode(const std::string\u0026amp; buf) { serialization_streambuf osrb((char*)buf.data(), buf.length()); std::istream ss(\u0026amp;osrb); int32_t d = 0; ss.read((char*)\u0026amp;a, sizeof(a)); ss.read((char*)\u0026amp;b, sizeof(b)); ss.read((char*)\u0026amp;c, sizeof(c)); ss.read((char*)\u0026amp;d, sizeof(d)); ss \u0026gt;\u0026gt; s; return ss.good(); } }; 可以看到，其实也很简单。就是模仿strstream为iostream构建streambuf就行了。这样不仅享受到了iostream类给我们提供的便利，也克服了stringstream需要内存拷贝的缺陷。\n参考引用 [1] std::strstream[EB/OL]. https://en.cppreference.com/w/cpp/io/strstream\n[2] Why was std::strstream deprecated?[EB/OL]. https://stackoverflow.com/questions/2820221/why-was-stdstrstream-deprecated\n","date":"November 18, 2020","hero":"/posts/c++/serialization/serialization_hero.png","permalink":"https://gqw.gitee.io/posts/c++/serialization/","summary":"在开发时我们经常会遇到需要序列号和反序列化得操作。比如将程序配置导出下次打开再从配置中读取，通常你可以将信息保存成json、xml或ini格式，让后再解析出来。更常见的情形是我们通过网络发送和接收数据，也涉及到序列化和反序列化操作，当让你可以使用protobuf、msgpack等序列化库。但是如果你只是个简单程序，或者序列化和反序列化的业务不是很重，不想搞得那么复杂有什么简单的方法吗？\n最直接的方法 直接按字节拷贝，见代码:\n#include \u0026lt;string\u0026gt; bool encode(const std::string\u0026amp; s, int32_t a, int32_t b, int32_t c, std::string\u0026amp; buf) { int32_t d = static_cast\u0026lt;int32_t\u0026gt;(s.length()); if (buf.size() \u0026lt; (sizeof(int32_t) * 4 + d)) return false; std::size_t pos = 0; memcpy(buf.data() + pos, \u0026amp;a, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;b, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;c, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, \u0026amp;d, sizeof(int32_t)); pos += sizeof(int32_t); memcpy(buf.data() + pos, s.","tags":null,"title":"C++序列化和反序列化工具"},{"categories":null,"contents":"\r\r缘起 前一阵子在查看asio库的时候看到在example目录中已经提供了coroutines_ts代码。很是好奇，便慢慢翻看代码，在感叹Coroutine给异步编程带来的优雅简洁的同时也带来了许多概念上的复杂和难以理解。由于C++ Coroutine还是一个比较新的概念，各个编译器厂商的实现还处于实验性的阶段[1] ，网上的资料少而松散。由此内心涌出一个念头想把自己的学习过程记录下来以期帮助后面学习的人。\n从HelloWorld说起 再过两年这个世界的第一条HelloWorld代码就要有50年历史了[2] ，在此先提前蹭下热点，:)\u0026hellip;\n#include \u0026lt;iostream\u0026gt;int main() { std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码1\r这是一段平淡无奇的符合C++98标准的代码，你甚至可以用古董级编译器GCC 4.3都能编译通过[3]。但是我希望通过对这段代码的演化带领大家学习了解C++ 20中的Coroutine。\n这段代码的作用很简单，打印一条\u0026quot;hello, world\u0026quot;，执行的也很快。但是这个世界并不总是那么简单美好，如果打印的逻辑非常耗时（特别是读取磁盘文件和进行网络请求时）而又需要频繁的调用就有些尴尬了，好了，我们改下代码来模拟这种情形：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; void remote_query() { // 假设这是个远程网络请求  std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { for (;;) { remote_query(); } return 0; } 代码2\r改过后的代码不停的进行耗时的远程调用，每次远程调用需要消耗4秒的时间才能返回。可以看到，每次进行调用时程序都要暂停住（也就是卡住）而做不了其它事情。如果这是个带UI(用户界面)的程序，每次进行调用界面就要卡住，用户肯定是不能忍受的。\n 注意\n上面的代码由于使用了thread[4](C++ 11)和chrono_literals[5](C++ 14)，所以编译器需要支持C++ 14标准。\n 多线程+Callback解决方案 为了解决上面的问题，我们对上面的代码进行如下改造：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; #include \u0026lt;string\u0026gt;#include \u0026lt;future\u0026gt; void remote_query(uint32_t query_index, std::function\u0026lt;void(uint32_t)\u0026gt;\u0026amp;\u0026amp; callback) { std::thread t( [query_index, callback = std::move(callback)]() { std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; std::to_string(query_index) + \u0026#34; times query: Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; callback(query_index); }); t.detach(); } void remote_callback(uint32_t query_index) { remote_query(++query_index, remote_callback); } int main() { remote_query(1, remote_callback); while (true) { std::this_thread::sleep_for(1s); std::cout \u0026lt;\u0026lt; \u0026#34;main thread doing other things...\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 代码3\r打印结果：\nmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r1 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r2 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\r是的，我们可以通过多线程解决卡顿的问题，但这是个好的方案吗？不说线程的开销（其实创建和销毁一个线程无论从时间还是空间上来说都是非常大的开销），单从代码的组织来看也足够让人头疼的了。上面的代码只是循环调用同样的远程方法，如果remote_callback调用remote_query1(另一个远程调用)，remote_query1回调中再调用remote_query2\u0026hellip;如此下去代码逻辑将会非常恐怖。如果不能明白我说的是什么意思，callback hell 了解下:)， 为什么说是恐怖，因为这完全不符合人类的思维逻辑。人类喜欢的代码是有条不紊的按步执行，而不是在各个回调中跳来跳去。最好就像前面的同步代码，一个请求走完再执行下一个请求。\n主角登场 有没有什么方法解决这种复杂性呢？有的，技术牛人们早已发现这个问题并且给出了设计模型，有类似于libevent的Reactor模式[6]，也有asio的Proactor模式[7]。但Reactor，Proactor模式的核心思想都是通过事先注册回调函数，收到消息再根据消息内容查找并执行回调，有效的将层层包裹的回调给摊平以达到降低回调函数管理的复杂度。但是无论Reactor还是Proactor调用逻辑和回调逻辑还是被硬生生的给割裂开了。如何弥合这里的割裂呢？这就需要请出我们今天的主角Corouter了，还是先看代码吧：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; #include \u0026lt;string\u0026gt;#include \u0026lt;future\u0026gt; std::future\u0026lt;std::string\u0026gt; remote_query(uint32_t query_index) { return std::async([query_index]() { std::this_thread::sleep_for(4s); return std::to_string(query_index) + \u0026#34; times query: Hello, world!\u0026#34;; }); } std::future\u0026lt;void\u0026gt; remote_query_all() { uint32_t query_index = 0; for (;;) { std::string ret = co_await remote_query(++query_index); std::cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; std::endl; } } int main() { remote_query_all(); while (true) { std::this_thread::sleep_for(1s); std::cout \u0026lt;\u0026lt; \u0026#34;main thread doing other things...\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 代码4\r打印结果：\nmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r1 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r2 times query: Hello, world!\rmain thread doing other things...\rmain thread doing other things...\rmain thread doing other things...\r看到了吗？打印结果还是一样的，但是回调没有了, 从代码上看函数remote_query_all的逻辑也是在一个for循环中按步执行。好了，讲到这里只是希望你能直观的体会到使用Coroutine的作用和好处，但是你心中一定会有n个问号。\n 这不科学呀，remote_query返回值不是std::future\u0026lt;std::string\u0026gt;吗？ 怎么直接赋值给std::string了？ co_await 又是什么鬼？ remote_query 是个异步调用, 返回的ret直接用会不会崩溃？ \u0026hellip;  请少安毋躁， 暂时按下心中的疑惑，因为这边的水很深，坑很大，不是三言两语能够解释的清楚的。我会尽量努力在后面的内容中消除你心中的困惑。\n先从定义说起 翻开cppreference看看协程的定义[8]：\n协程是能暂停执行以在之后恢复的函数。协程是无栈的：它们通过返回到调用方暂停执行，并且从栈分离存储恢复所要求的数据。这允许编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O），还支持对惰性计算的无限序列上的算法及其他用途。\r若函数的定义做下列任何内容之一，则它是协程：\r. 用 co_await 运算符暂停执行，直至恢复\r. 用关键词 co_yield 暂停执行并返回一个值\r. 用关键词 co_return 完成执行并返回一个值\r读完之后似乎还是什么都不知道，好吧，现在我们试着逐句翻译成“白话文”。\n  协程是能暂停执行以在之后恢复的函数。\n这里的协程就是前面说的Coroutine, 这句说出了协程的本质。首先它是一个函数，然后这个函数与普通函数的区别是能够“暂停”和“恢复”执行代码。所以协程最关键的点是“暂停”和“恢复”。用一段代码说明下：\n void foo() {\rcode1;\rcode2;\rcode3;\r}\rint main() {\rfoo();\rreturn 0;\r}\r代码5\r这是一段普通的代码，代码从main函数开始，先调用foo函数，接着依次调用code1、code2、code3，然后返回main函数，最后执行return 0。这种执行顺序是我们见到的最常见的顺序，代码逐行执行，按部就班符合我们的预期。但是如果是协程，代码就可以在执行完code1后立马返回到main函数，在适当时候再返回foo执行code1后面的代码code2——这就是前面所谓的“暂停”和“恢复”。其实仔细想想所谓协程也只是计算机执行顺序的一种规范，有点类似goto指令，都是用于改变常规的代码执行顺序，只是这些规范我们用的比较少见而已。其实翻阅维基百科的“协程”页面[9]，你会发现其实协程历史并不短，起码已经超过半个世纪了。但是直到最近几年才开始火热是有原因的，就像goto语句一样，过多的自由有时也是一种灾难（代码逻辑混乱，难以维护）。但是随着计算机硬件的发展（多核多线程）和一些成熟的案例（如腾讯的libco[10]和golang[11]）出现，让人们认识到了协程的优势和闪光点。\n  协程是无栈的。\n“无栈” 两个字隐藏了太多的概念，对于一个完全没有接触过协程的人来说这个概念太含糊和陌生了。这里的“无栈”是相对于协程的另一种实现方式“有栈”协程而言的。在介绍这两个概念前先看下普通函数调用堆栈。函数堆栈非正式的理解就是函数调用时申请的用于存放参数和临时变量的内存块，按照后进先出（LIFO, Last In First Out）的规则分配内存，因为只有push和pop两种操作所以比较简单和快捷，由编译器自动管理其分配内存的生命周期。 在https://godbolt.org/里写下测试代码得到如下汇编指令：\n\r图1 函数调用汇编分析源码\r\r经过简单整理可得到堆栈的使用情况如下图所示：\n\r图2 函数调用堆栈变化\r\r 注意\n上面的代码是使用x64位的msvc编译的，和经常见到x86版本相比64位版本的更加简洁易懂，少了“基址指针寄存器”的概念所以省去了保存和恢复基址指针的操作。这里也没有常规的push和pop操作，而是直接通过sub和add相应的地址偏移获得相同的效果。\n 通过上面的分析我们可以看到，每次进行函数调用我们都需要为被调用的函数分配栈空间，用以保存调用参数和局部变量。为了实现协程，我们必须要实现前面说的“暂停”和“恢复”特性。有栈协程为了实现这两个特性做法是想办法在暂停后保存这些参数、变量以及相关的寄存器，在需要恢复调用前再将保存的信息恢复。在Linux中可以调用ucontext族函数getcontext、setcontext等实现[12]；Boost库也有类似的实现Boost.Context[13]；甚至可以自己通过汇编实现，例如微信的libco[14]。\n无栈协程不需要此过程。 在《使用 C 语言实现协程》[15]文章作者详细介绍了一种利用达夫设备[16]原理使用C语言实现协程的方法。由于原理比较简单在此粗略的介绍下其核心代码：\nint function(void) { static int i, state = 0; switch (state) { case 0: // 函数开始执行  for (i = 0; i \u0026lt; 10; i++) { state = 1; // 我们会回到 \u0026#34;case 1\u0026#34; 的地方  return i; case 1:; // 从上一次返回之后的地方开始执行  } } return i; } 代码6\r这段奇怪的代码之所以能够正确执行是因为C语言标准规定：“在switch控制语句内，条件标号（case）可以出现在任意子语句之前，充作其前缀” [[16]](#ref_16)。现在分析下代码：\r第1次调用function()时, state值为0，所以执行case 0，然后执行for循环体，i赋0， state赋1(相当于保存状态，暂停执行)，函数返回i(0)。 第2次调用function()时, state值为1，执行case 1（相当于恢复状态，继续执行），执行for循环后面的语句，i++， state赋1，函数返回i(1)。 第3次调用function()时, state值为1，执行case 1，执行for循环后面的语句，i++， state赋1，函数返回i(2)。 \u0026hellip;\n第10次调用function()时, state值为1，执行case 1，执行for循环后面的语句，i++， state赋1，函数返回i(9)。 第11次调用function()时, state值为1，执行case 1，因为i\u0026gt;=10所以跳出循环，函数返回i(9)。\n由此可见，通过一个状态量，便可改变每次函数的执行流程。看到这里也许你会有疑问，为什么要用这么复杂的语法，if-else不也可以实现吗？其实这样写主要方便利用宏进行代码封装，具体的做法可见参考文献[15]。其实在C++协程标准的实现里面也有类似的做法，只不过是编译器通过汇编指令直接跳转实现的，具体的分析后面会介绍。\n  它们通过返回到调用方暂停执行。这里说的是协程的非对称性，协程按照调度方式可以分为对称协程和非对称协程[17]。\n 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。  直白的说就是， 对称协程只提供了一种类似于goto的操作将控制权直接传递给其它指定的协程，而非对称协程需要前面所说的“暂停”和“恢复”两种操作。对于对称协程调用者和被调用者之间的关系是平等的，他们甚至可以互相调用，可以做到A-\u0026gt;B-\u0026gt;C-\u0026gt;A（A,B,C为不同的协程函数）这样的链式调用。非对称协程具有明确的层级关系被调用者必须先返回到调用者再调用其他协程，如A-\u0026gt;B-\u0026gt;A-\u0026gt;C-\u0026gt;A。粗看好像对称协程更容易使用，因为其具有更大的自由度，但是它和goto遇到的问题是一样的，在一个复杂的系统里过多的自由跳转会破坏代码的结构，让程序逻辑不容易得到把控。例外对称协程只是非对称协程的一个特例，我们可以通过添加一个中立的第三方调度中心的方式将非对称协程转换成对称协程（只需要在所有协程“暂停”时将控制权转交给调度中心统一调度即可）。\n  并且从栈分离存储恢复所要求的数据。这里所说是相对于普通的函数调用，如图1，图2所示，我们在调用函数时总是会先将调用参数和临时变量以及一些相关寄存器信息压入堆栈，在后面的指令需要时再从堆栈中取出，最后函数执行完后清理掉。但是协程具有额外的“暂停”和“恢复”操作，如果还是使用堆栈上的信息，根据堆栈的使用规则，协程“恢复”后堆栈已经遭到破坏，因为“暂停”后为了使调用者能够正常工作，我们必须保证此时的堆栈状态能够恢复到调用者的堆栈状态，“恢复”后由于协程的堆栈信息已经丢失，我们无法再使用协程的堆栈。所以我们需要额外的手段将这些信息存储在其他地方（一般是在堆上）。值得注意的是这里的用词是“分离”而不是复制，具体实现后面做详细的分析。\n  这允许编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O）。 参考前面代码4的例子。\n  还支持对惰性计算的无限序列上的算法及其他用途。\n  无限序列（infinite sequence）是指一列或一串离散的数字能够与另一组正整数$$\\{0, 1, 2, 3, \u0026hellip;\\}$$相比而形成一定的联系和概念。例如无限序列 $$ N=(0, 1, 2, 3, \u0026hellip;) $$ 和 $$ S＝(1, \\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}, \u0026hellip;, \\frac{1}{2^n}, \u0026hellip;) $$, 当然斐波纳契数列$$ F＝(1, 1, 2, 3, 5, 8, \u0026hellip;, n_{i-1}, n_{i}, n_{i-1} + n_{i}, \u0026hellip;) $$也是一种无限序列。\n  惰性计算（又称延迟求值）在科学计算和函数式编程中经常用到的一种优化手段。引用Wiki中给的例子简单说明下， 下面是部分代码[19]:\nmatrix A,B; A[3][4]=101; B[3][4]=102; matrix_add R=A+B; int result = R[3][4]; 上面的代码是计算两个矩阵（A, B）相加后得到新矩阵(R)某个索引的值。通常我们在执行完R=A+B时便会算出R中的所有元素，因为A和B均有$12=3\\times4$个元素，所以为了得到R需要经过12次加法运算，但是我们只需要R[3][4]这一个元素的值，所以我们浪费了11次运算。惰性计算的方法是执行到R=A+B时，我们并不去计算，而只是存储计算所需要的数据，计算被延迟到了取R[3][4]值时才开始。完整的代码请参考Wiki[19]。\n  我们通过cppcoro计算斐波纳契的例子来说明下C++协程是怎么实现惰性计算的。\ncppcoro::generator\u0026lt;const std::uint64_t\u0026gt; fibonacci() { std::uint64_t a = 0, b = 1; while (true) { co_yield b; // 2  auto tmp = a; a = b; b += tmp; } } void usage() { for (auto i : fibonacci()) // 1  { if (i \u0026gt; 1\u0026#39;000\u0026#39;000) break; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } 在代码注释1处，我们通过循环不停调用fibonacci， 第一次调用fibonacci时从函数入口开始初始化a, b，然后进入循环，执行 co_yield b; 这是会从fibonacci函数回到usage，执行for循环体中代码，再次调用fibonacci时实际上执行的是fibonacci协程的的resume方法，所以再次进入fibonacci函数时并不是从入口重新执行，而是恢复到co_yield后面的语句auto tmp = a;继续执行算出数列的下个值b，然后循环再次co_yield回到usage，如此循环往复，最终得到数列中第1'000'000个值。  可以看到第一次调用时我们并没有把fibonacci数列中的前1'000'000个值全部计算出来，而是把计算推迟到了后面的调用。如果有足够的时间和算力我们可以计算任意数列的值，从算法上并不限制数列的长度，可以无限的计算下去， 所以说是“无限序列”。\n    若函数的定义做下列任何内容之一，则它是协程。 简单的说就是如果一个函数中出现co_await、co_yield、co_return 三个关键字，你就可以认为它是一个协程函数。\n  原理剖析 C++语言的难学已经是恶名远播，提起C++时许多程序员（甚至是学C语言的程序员）第一反应就是“这是个令人胆颤、难缠、恶心的家伙”。其实换个角度C与C++的关系非常类似于JavaScript和Typescript(如果你用过应该很好理解)，C++作为C的超集经过编译器的转换绝大部分的代码是可以转换成C，因为有了编译器的帮助C++可以实现许多高级的封装，每次编译时编译器都会根据需要向用户编写的代码里“偷偷”加料。例如构造析构函数的自动创建、虚函数表、this指针传递等等，对于这方面的知识建议大家看看《深入了解c++内核对象模型》这本书。因为编译器的这些小动作对用户是无感知的，这就造成了用户对C++一些行为表现的困惑，也加大了大家学习C++的难度。而协程特性是我目前见到C++让编译器加料最多的一次，理所当然理解的难度指数也是陡增。现在就让我们细细的分析下编译器给我们加的这些料的配方吧！\n协程函数展开  让我们看个最简单的例子，看看main函数调用remote_query_all时发生了什么。\n我们先定义个函数返回对象的类型return_ignore，为什么要定义它以及怎么定义我们后面介绍，提前申明只是不想干扰后面的分析，如果不清楚具体的含义就先无视它。\nstruct return_ignore { struct promise_type { return_ignore get_return_object() { return return_ignore{}; } auto initial_suspend() { return std::experimental::suspend_always{}; } auto final_suspend() { return std::experimental::suspend_never{}; } void unhandled_exception() { } void return_void() {} }; }; 下面是我们现在需要关注的代码，为了排除干扰我已经做了最大程度的精简。test_coroutine的模板参数其实是不必要的，但是为了通用性还是加上了。\n#include \u0026lt;experimental/coroutine\u0026gt; template\u0026lt;typename ...Args\u0026gt; return_ignore test_coroutine(Args... args) { co_await std::experimental::suspend_always{}; } int main() { test_coroutine(); return 0; } 下面我们看看编译器展开test_coroutine函数后的代码成什么样子， Gor Nishanov和luncliff对其做了精彩的分析，推荐看看他们的报告[21][22]，下面是我结合他们俩的报告整理出来的全部展开：\ntemplate\u0026lt;typename ...Args\u0026gt; return_ignore test_coroutine(Args... args) { using T = coroutine_traits\u0026lt;return_type, Args...\u0026gt;; using promise_type = T::promise_type; using frame_type = tuple\u0026lt;frame_prefix, promise_type, Args...\u0026gt;; auto *frame = (frame_type *)promise_type::operator new(sizeof(frame_type)); auto *p = addressof(get\u0026lt;1\u0026gt;(*frame)); return_ignore*__return_object; *__return_object = { p-\u0026gt;get_return_object() }; { // co_await p-\u0026gt;initial_suspend();  auto\u0026amp;\u0026amp; tmp = p-\u0026gt;initial_suspend(); if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = n;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_n: tmp.await_resume(); } try { // co_await std::experimental::suspend_always{};  { auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_m: p-\u0026gt;return_void(tmp.await_resume()); // p-\u0026gt;return_value(tmp.await_resume());  } goto __final_suspend_point; } catch (...) { p-\u0026gt;unhandled_exception(); } __final_suspend_point: co_await p-\u0026gt;final_suspend(); __destroy_point: promise_type::operator delete(frame, sizeof(frame_type)); } 哈哈，惊不惊喜？意不意外？你的一行代码，编译器给你加了这么多东西。上面的代码对理解协程非常重要，它就像导航地图里面的预览图一样，在你学习协程的各种知识和概念是不被绕晕。我在刚开始学习协程时就因为缺乏对全局的理解，导致当面对一大堆新的概念时不说其它的，心理上就有莫大压力，想理清它们关系也无所适从，希望上面的代码能够帮助到你。\n 注意\n上面的代码并非真实的代码，只是根据文献和逆向推导而来，而且各个编译器厂商实现也有差异，这里列出的代码只是帮助大家理解而已。\n 下面我们对照着上面的代码说说协程的几个重要概念。\nco_await 表达式 co_await 表达式， 就是我们在co_await关键词后面的运算对象(operand)，这个运算对象必须满足特定的规则：必须包含await_ready、await_suspend、await_resume三个函数。通过展开的代码我们很容易理解为什么做这样的规定。例如我们前面例子中std::experimental::suspend_always的定义是这样的：\nstruct suspend_always { bool await_ready() noexcept { return false; } void await_suspend(coroutine_handle\u0026lt;\u0026gt;) noexcept {} void await_resume() noexcept {} }; co_await 表达式展开后是这样的：\n// co_await std::experimental::suspend_always{}; { auto\u0026amp;\u0026amp; tmp = std::experimental::suspend_always{}; if (!tmp.await_ready()) { __builtin_coro_save() // frame-\u0026gt;suspend_index = m;  if (tmp.await_suspend(\u0026lt;coroutine_handle\u0026gt;)) { __builtin_coro_suspend() // jmp  } } resume_label_m: tmp.await_resume(); } 可以看到展开后直接调用了运算对象的await_ready、await_suspend、await_resume三个方法。那么这三个函数式作什么用的呢？\n await_ready: 在暂停协程前给了一次机会，判断是否可以避免异步调用以达到节省暂停带来的开销。 await_suspend：可以看做是暂停前的准备，通常我们在这个函数中分配任务系统，线程去完成异步完成，然后进入暂停状态。注意这个函数有一个非常重要的参数coroutine_handle(协程句柄)，通过这个句柄我们可以操控协程的状态，通常我们需要将这个句柄保存起来，在适当的时机（异步任务完成时）通过它恢复当前协程。 await_resume：这个很好理解，协程恢复后执行的代码，值得注意的是恢复后而不是回复前。  承诺（promise）对象 编译器用 std::coroutine_traits 从协程的返回类型确定 Promise 类型[8]。也就是说编译器会根据你的协程函数放回值类型去确定Promise类型，确定方法就是看你的返回类型有没有promise_type的定义，比如return_ignore的Promise类型就是return_ignore::promise_type。这个Promise类型类似于std::promise，应为是异步所以无法立即给你结果，但是我承诺你将来你可以向我申请查询结果。同样通过展开代码我们可以看到编译器调用了Promise的许多方法，所以我们在定义promise_type时必须符合编译的规范和需求。下面是promise_type必须具有的接口：\n  get_return_object: 按照规定该调用的结果将在协程首次暂停时返回给调用方[8]。调用者可以通过此函数返回的对象获得协程函数最终的结果。可以参考return_ignore的代码，这里需要注意的是我们不能将结果保存在promise_type里，因为协程函数结束时会析构这个对象，保存的数据会丢失。可选的方案是在promise_type中保存返回对象然后在返回去，如下面的代码，但是返回值类型是个问题，如果返回_ret指针，promise_type析构后_ret一样会被收回，返回对象会多出一份数据，return_value函数操作的还不是同一个对象, 所以_value只能是个指针类型。还有个小的问题是直接在内部类声明外面的类对象会导致类型未定义的错误，只能放到类定义外面定义内部类。\nstruct return_object { struct promise_type; int get_ret() { return *_value; } private: std::shared_ptr\u0026lt;int\u0026gt; _value = std::make_shared\u0026lt;int\u0026gt;(0); }; struct return_object::promise_type { return_object get_return_object() { return _ret; } ... void return_value(int value) { *_ret._value = value; } return_object _ret; }; 另一个方案是在promise_type类中提供个方法让返回对象将this指针传给promise_type类，相当于来了个回马枪：\nstruct return_object { struct promise_type { return_object get_return_object() { return return_object(this); } void set_return_object(return_object* ret) { _ret = ret; } auto initial_suspend() { return std::experimental::suspend_never{}; } auto final_suspend() { return std::experimental::suspend_never{}; } void unhandled_exception() { } void return_value(int value) { _ret-\u0026gt;_value = value; } return_object* _ret = nullptr; }; int get_ret() { return _value; } private: return_object(promise_type* p) { p-\u0026gt;set_return_object(this); } int _value = 0; };   initial_suspend: 控制是否在进入协程函数前先暂停协程。\n  initial_suspend: 做些收尾工作。\n  unhandled_exception: 参考展开代码，捕获到异常时调用此方法。\n  return_value, return_void: 这两个函数根据协程函数内的co_return表达式二选一即可，协程函数遇到co_return会根据表达式内容调用这两个函数之一，并将结果传递给放回对象。\n  协程句柄 (coroutine handle) 这是用于恢复协程执行或销毁协程帧的非拥有柄。前面的“承诺对象”是从内部控制协程，将异常和结果传递给系统外部，而协程句柄正好相反，它提供了从外部操控协程的方法。先看下结构声明：\ntemplate \u0026lt;\u0026gt; struct coroutine_handle\u0026lt;void\u0026gt; { // no promise access  static coroutine_handle from_address(void* _Addr); void* address() const noexcept; void operator()() const noexcept { resume(); } void resume() const { _coro_resume(_Ptr); } void destroy() { _coro_destroy(_Ptr); } bool done() const { return _Ptr-\u0026gt;_Index == 0; } struct _Resumable_frame_prefix { using _Resume_fn = void(__cdecl*)(void*); _Resume_fn _Fn; uint16_t _Index; uint16_t _Flags; }; protected: _Resumable_frame_prefix* _Ptr = nullptr; }; 在协程句柄中我们看到一个非常重要的方法resume和一个frame_prefix的成员变量，resume方法应该不用多说了，调用它可以将协程从“暂停”的地方“恢复”。有意思的是_Ptr这个指针，它的类型是_Resumable_frame_prefix, 其中包括一个函数指针_Fn和两个状态值。_Fn其实就是协程跳转后真正执行的函数地址，它通过和_Index配合能够跳转到协程暂停后的指令地址。具体的分析参考后面的协程跳转相关内容。\n协程状态 (coroutine state) 可以把协程状态理解为为使协程正常工作在堆上申请分配的内存，这里面包括前面说过的承诺对象、参数、临时变量和协程句柄里面记录的_Resumable_frame_prefix内容。\n协程跳转 在协程展开代码中还有两个函数__builtin_coro_save和__builtin_coro_suspend，这其实是编译器内置的代码，在msvc的头文件experimental\\resumable中你可以看到许多以_coro_开头的类似函数，这些函数式协程实现的基础。下面我们以一个简单的例子，通过跟踪汇编代码来看下编译器是怎么实现协程的“暂停”和“恢复”操作的。\nstd::experimental::coroutine_handle\u0026lt;\u0026gt; g_h; struct awaitee { bool await_ready() noexcept { return false; } void await_suspend(std::experimental::coroutine_handle\u0026lt;\u0026gt; h) noexcept { g_h = h; } void await_resume() noexcept {} }; template\u0026lt;typename ...Args\u0026gt; return_object test_coroutine(Args... args) { co_await awaitee(); co_return 1; } int main() { auto\u0026amp; ret = test_coroutine(); if (ret.get_ret() == 0) { g_h.resume(); } std::cout \u0026lt;\u0026lt; \u0026#34;coroutine ended.\u0026#34; \u0026lt;\u0026lt; ret.get_ret() \u0026lt;\u0026lt; std::endl; return 0; } ; test_coroutine xor edi,edi mov ecx,100h add rcx,28h call operator new (07FF6282C10CDh) ; 在堆上分配协程帧内存 lea r9,[a] ；向_InitCoro 传递 test_coroutine 参数 a mov dword ptr [rsp+170h],edi mov r8,rbx lea rcx,[rsp+170h] lea rdx,[rax+10h] ; 计算协程句柄地址 lea rax,[b] ；向_InitCoro 传递 test_coroutine 参数 b mov qword ptr [rsp+20h],rax call test_coroutine$_InitCoro$1 (07FF6282C1630h) ; 调用初始化协程的内置函数 请在后面注意这里的内存变化： 这里值得一提的是计算协程句柄地址中的偏移地址10h, 这个值怎么来的呢？ 翻看msvc中resumable头文件，可以看到coroutine_handle的定义：\ntemplate \u0026lt;typename _PromiseT\u0026gt; struct coroutine_handle : coroutine_handle\u0026lt;\u0026gt; { static coroutine_handle from_promise(_PromiseT\u0026amp; _Prom) noexcept { auto _FramePtr = reinterpret_cast\u0026lt;char*\u0026gt;(_STD addressof(_Prom)) + _ALIGNED_SIZE; coroutine_handle\u0026lt;_PromiseT\u0026gt; _Result; _Result._Ptr = reinterpret_cast\u0026lt;_Resumable_frame_prefix*\u0026gt;(_FramePtr); return _Result; } ... static const size_t _ALIGN_REQ = sizeof(void*) * 2; static const size_t _ALIGNED_SIZE = is_empty_v\u0026lt;_PromiseT\u0026gt; ? 0 : ((sizeof(_PromiseT) + _ALIGN_REQ - 1) \u0026amp; ~(_ALIGN_REQ - 1)); _PromiseT\u0026amp; promise() const noexcept { return *const_cast\u0026lt;_PromiseT*\u0026gt;( reinterpret_cast\u0026lt;_PromiseT const*\u0026gt;(reinterpret_cast\u0026lt;char const*\u0026gt;(_Ptr) - _ALIGNED_SIZE)); } }; 从中分析可以知道promise地址（实际上就是协程栈的地址）与协程句柄的帧前缀地址是可以互相转换的，这两个地址之间相差了_ALIGNED_SIZE字节，所以得到一个地址相加或相减便能转换成另一个地址。那么_ALIGNED_SIZE是怎么算出来的呢？其实这是根据我们定义的promise_type的大小进行字节对齐（两倍的sizeof(void*)）得到的。例如我们定义的return_object::promise_type里面有一个指针成员变量，所以它的大小为8（64位机器）在和sizeof(void*) * 2 == 16 == 10h对齐后得到的结果便是16即10h, 如果我们在promise_type里面定义三个指针变量，大小变为24与16字节对齐后变为32即20h。\n下面我们继续分析_InitCoro函数：\nmov qword ptr [rsp+10h],rdx ; 从前面的分析我们知道rdx其实是协程句柄帧前缀的地址 sub rsp,28h mov r11d,100h mov rax,qword ptr [\u0026amp;b] ; 参数b mov r10d,dword ptr [rax] mov eax,dword ptr [r9] ; 参数a mov dword ptr [rdx+r11+10h],eax ; 加参数a, 存入协程栈 mov dword ptr [rdx+r11+14h],r10d ; 将参数b, 存入协程栈 lea rax,[test_coroutine$_ResumeCoro$2 (07FF6282C2FF0h)] ; 协程函数入口地址 mov qword ptr [rdx],rax ; 初始化协程句柄帧前缀的_Fn变量 mov eax,10002h ; 初始化协程句柄帧前缀的_Index和_Flags变量， 注意这里的_Index初始化值为2 mov r9d,2 cmp dword ptr [rcx],0 cmovne eax,r9d mov dword ptr [rdx+8],eax xor eax,eax mov dword ptr [r8],eax mov qword ptr [rdx-10h],r8 ; 初始化我们定义的 promise_type 的 _ret 变量 ; 注意这里的地址是 rdx-10h，即协程帧地址 mov byte ptr [rdx+r11],al mov rcx,rdx call test_coroutine$_ResumeCoro$2 (07FF6282C2FF0h) nop add rsp,28h ret 接着看下_ResumeCoro：\nmov qword ptr [rsp+8],rcx sub rsp,38h mov r8,qword ptr [\u0026lt;coro_frame_ptr\u0026gt;] ; 帧地址 movzx eax,word ptr [r8+8] ; 获得_Index值 mov word ptr [rsp+20h],ax inc ax ; _Index + 1，获得`恢复`索引， _Index为`暂停`索引 cmp ax,8 ja test_coroutine$_ResumeCoro$2+12Dh (07FF6282C311Dh) movsx rax,ax lea rdx,[__ImageBase (07FF6282C0000h)] ; 获取索引表 mov ecx,dword ptr [rdx+rax*4+3124h] ; 计算下条指令的执行地址偏移 add rcx,rdx ; 计算下条指令的执行地址 jmp rcx ; 跳转 这段代码可以说是协程实现的最关键的地方了，通过指令mov ecx,dword ptr [rdx+rax*4+3124h] 我们甚至可以猜测到隐藏在编译器后面整个实现逻辑。因为编译器在编译时知道我们所有代码的执行地址，所以编译器在生成程序时帮我建立了一张表\n   恢复点地址     恢复点1   恢复点2   \u0026hellip;    编译器每次遇到co_await, co_yied, 或者其他需要暂停恢复的地方都往这个表里添加一条记录。在执行时每次暂停，恢复时修改_Index值来动态找到需要跳转的地址。解释下为什么_Index初始化时值为2， 因为第一个暂停点和恢复点时留给cancel操作的。怎么样这里的逻辑是不是有点“达夫设备”的感觉，只是编译器做的更好。下面我们来验证下各个跳转点：\n从上面的代码可以看出，rcx是一个内存映射好的地址，现在让我们分别加上前面的地址偏移看看jmp最终跳转到的代码时什么。\n  第1个 rax = rcx + (rcx+0*4+34E8h) = 0x00007ff7eca10000 + 0x000034a1 （注意这里的字节序，需要反过来取值） = 0x00007ff7eca134a1，\n  第2个 rax = rcx + (rcx+1*4+34E8h) = 0x00007ff7eca10000 + 0x000034cb = 0x00007ff7eca134cb 看下0x00007ff7eca134a1和0x00007ff7eca134cb地址处的代码： 可以很容易的发现这是_resumable_cancel函数的进入和退出点， 同样我们再看看根据后面几个值算出的地址是什么代码。\n  第3个00007FF7ECA13431是 promise_type展开中的 co_await initial_suspend() 代码 这是 co_await initial_suspend() 的代码\n  第4个0x00007ff7eca12c4f是 第一次进入协程函数的代码。\n  第5个0x00007ff7eca12c4a是 0x00007ff7eca12c4f 失败时的恢复点。\n  第6个0x00007ff7eca12e20是 第一次调用 co_await awaitee() 恢复后代码。\n  第7个0x00007ff7eca12e1b是 0x00007ff7eca12e20 失败时的恢复点。\n  第8个0x00007ff7eca130da是 第二次调用 co_await awaitee() 恢复后代码。\n  第9个0x00007ff7eca130d5是 0x00007ff7eca130da 失败时的恢复点。\n从上图可以看到每次失败时都会跳转到 0x00007ff7eca134a1 即 _resumable_cancel函数的进入点。\n  总结 协程最关键的操作是暂停和恢复函数的执行，C++20中的协程借助于编译器在编译期插入相关代码、记录相应跳转点然后运行期根据协程状态计算跳转地址实现协程的各种功能。希望经过本文的讲解和分析后能够帮助大家更为深刻的了解和理解协程的机理，能够让大家放下对协程的恐惧，在以后的使用中能够更加自信。\n比如很多人在使用协程时都会想协程时线程安全的吗？其实在我看来这是个伪命题，既然是问是否是线程安全，那么肯定要出现资源被多个线程竞争的情况。但是从我们前面的例子可以看出整个代码都是在一个线程执行的，所以谈不上线程安不安全。当然如果我们改下前面的代码，将resume的调用放在不同线程里面执行，这种情况下协程函数中如果使用了共享的对象，那肯定不是线程安全的。至于网上许多说协程没有线程安全问题应该是指在一个协程函数中多次暂停和恢复，由于是顺序进行的，所以协程对象上的变量在此过程中不会存在竞争，可以说是线程安全的。总之，线程是否安全关键还是看线程而不是协程，协程只是改变代码执行流程的一种手段。\n在使用协程时，我们关心的另一问题就是性能效率问题。在理解C++的协程原理后我们知道建立一个协程函数后需要建立个协程对象，这个协程对象中包含承诺对象、形参信息、临时变量、协程句柄。与回调函数比起来真正多出来的应该只有协程句柄内包含的信息，承诺对象相当于返回值， 形参和临时变量回调函数也是少不了的（协程经过编译器优化可以直接在堆上分配），而协程句柄的内存也是极少的（只有一个函数指针和两个状态值）。对于执行时间，协程跳转只需计算一个地址然后直接跳转，效率上不会比一次函数调用差多少。所以C++的协程无论是空间还是时间复杂度性能都是相当可观的。\n最后，回到开头我是因为看到asio中的协程示例才开始学习研究C++ Coroutine的，但是此文通篇都没有提及asio， 所以在下篇文章中我会带大家一起学习研究下asio是怎样使用协程实现异步调用的。\n参考引用 [1] C++ compiler support[EB/OL]. https://en.cppreference.com/w/cpp/compiler_support\n[2] \u0026ldquo;Hello, World!\u0026rdquo; program[EB/OL].https://en.wikipedia.org/wiki/%22Hello,_World!%22_program\n[3] C++ Standards Support in GCC[EB/OL].https://gcc.gnu.org/projects/cxx-status.html#cxx98\n[4] std::this_thread::get_id[EB/OL].https://en.cppreference.com/w/cpp/thread/get_id\n[5] User-defined literals[EB/OL].https://en.cppreference.com/w/cpp/language/user_literal%23Standard_library\n[6] reactor反应堆模式[EB/OL].https://aceld.gitbooks.io/libevent/content/31_reactorfan_ying_dui_mo_shi.html\n[7] Proactor and Boost.Asio[EB/OL].https://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio/overview/core/async.html\n[8] Coroutines (C++20) [EB/OL].https://en.cppreference.com/w/cpp/language/coroutines\n[9] 协程 [EB/OL].https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B\n[10] Tencent/libco[EB/OL].https://github.com/Tencent/libco\n[11] Go Language Patterns/Coroutines[EB/OL].http://www.golangpatterns.info/concurrency/coroutines\n[12] setcontext(2) - Linux man page[EB/OL].https://linux.die.net/man/2/setcontext\n[13] Boost.Context[EB/OL].https://www.boost.org/doc/libs/1_74_0/libs/context/doc/html/context/overview.html\n[14] Libco[EB/OL].https://github.com/Tencent/libco\n[15] 使用 C 语言实现协程[EB/OL].https://mthli.xyz/coroutines-in-c/\n[16] 达夫设备[EB/OL].https://en.wikipedia.org/wiki/Duff%27s_device\n[17] 破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现[EB/OL].https://www.bennyhuo.com/2019/12/01/coroutine-implementations/\n[18] infinite sequence：无限序列[EB/OL].https://searchcio.techtarget.com.cn/whatis/8-28809/\n[19] 惰性求值[EB/OL].https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC\n[20] CppCoro - A coroutine library for C++[EB/OL].https://github.com/lewissbaker/cppcoro\n[21] Exploring the C++ Coroutine[EB/OL].https://raw.githubusercontent.com/CppCon/CppCon2016/master/Presentations/C%2B%2B%20Coroutines%20-%20Under%20The%20Covers/C%2B%2B%20Coroutines%20-%20Under%20The%20Covers%20-%20Gor%20Nishanov%20-%20CppCon%202016.pdf\n[22] Exploring the C++ Coroutine[EB/OL].https://luncliff.github.io/coroutine/ppt/%5BEng%5DExploringTheCppCoroutine.pdf\n  ","date":"October 1, 2020","hero":"/posts/c++/coroutine/coroutine.md.assets/hero.jpg","permalink":"https://gqw.gitee.io/posts/c++/coroutine/","summary":"缘起 前一阵子在查看asio库的时候看到在example目录中已经提供了coroutines_ts代码。很是好奇，便慢慢翻看代码，在感叹Coroutine给异步编程带来的优雅简洁的同时也带来了许多概念上的复杂和难以理解。由于C++ Coroutine还是一个比较新的概念，各个编译器厂商的实现还处于实验性的阶段[1] ，网上的资料少而松散。由此内心涌出一个念头想把自己的学习过程记录下来以期帮助后面学习的人。\n从HelloWorld说起 再过两年这个世界的第一条HelloWorld代码就要有50年历史了[2] ，在此先提前蹭下热点，:)\u0026hellip;\n#include \u0026lt;iostream\u0026gt;int main() { std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码1\r这是一段平淡无奇的符合C++98标准的代码，你甚至可以用古董级编译器GCC 4.3都能编译通过[3]。但是我希望通过对这段代码的演化带领大家学习了解C++ 20中的Coroutine。\n这段代码的作用很简单，打印一条\u0026quot;hello, world\u0026quot;，执行的也很快。但是这个世界并不总是那么简单美好，如果打印的逻辑非常耗时（特别是读取磁盘文件和进行网络请求时）而又需要频繁的调用就有些尴尬了，好了，我们改下代码来模拟这种情形：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;using namespace std::chrono_literals; void remote_query() { // 假设这是个远程网络请求  std::this_thread::sleep_for(4s); std::cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { for (;;) { remote_query(); } return 0; } 代码2\r改过后的代码不停的进行耗时的远程调用，每次远程调用需要消耗4秒的时间才能返回。可以看到，每次进行调用时程序都要暂停住（也就是卡住）而做不了其它事情。如果这是个带UI(用户界面)的程序，每次进行调用界面就要卡住，用户肯定是不能忍受的。\n 注意\n上面的代码由于使用了thread[4](C++ 11)和chrono_literals[5](C++ 14)，所以编译器需要支持C++ 14标准。\n 多线程+Callback解决方案 为了解决上面的问题，我们对上面的代码进行如下改造：","tags":null,"title":"从HelloWold开始，深入浅出C++ 20 Coroutine TS"},{"categories":null,"contents":"\\documentclass[UTF8]{ctexart} \\usepackage{markdown} \\begin{document} \\begin{markdown}\n我是 Markdown 这里可以用 Markdown 语法，撰写各种内容。例如，我可以强调，也可以加粗，当然也可以加粗并强调。\n这里是二级标题  幸福的获得，在极大的程度上却是由于消除了对自我的过分关注。 \u0026mdash;Bertrand Arthur William Russell\n 你看，我还可以使用引用↑。\n关于 dash, en-dash 和 em-dash LaTeX 使用者都应该知道 dash, en-dash 和 em-dash。dash 是普通的连字符，举例如：「five-year-old boy」。en-dash 是表示范围的稍长的横线，举例如：「以下章节是重点：12\u0026ndash;15」。em-dash 则是英文中的破折号，举例如：「\u0026mdash;Bertrand Arthur William Russell」 \\end{markdown} \\end{document}\n\r\rmath \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\ronload=\u0026quot;renderMathInElement(document.body, {\r// customised options\rdelimiters: [\r{left: '$$', right: '$$', display: true}, // 独立一行显示\r{left: '$', right: '$', display: false}\t// 行内显示\r]\r});\u0026quot;\u0026gt;\r\u0026lt;/script\u0026gt;\r数学数列 $ E=mc^2 $： $$ F＝(1, 1, 2, 3, 5, 8, ..., n_{i-1}, n_{i}, n_{i-1} + n_{i}, ...) $$ 显示效果：\n数学数列 $ E=mc^2 $： $$ F＝(1, 1, 2, 3, 5, 8, \u0026hellip;, n_{i-1}, n_{i}, n_{i-1} + n_{i}, \u0026hellip;) $$\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/posts/test/","summary":"\\documentclass[UTF8]{ctexart} \\usepackage{markdown} \\begin{document} \\begin{markdown}\n我是 Markdown 这里可以用 Markdown 语法，撰写各种内容。例如，我可以强调，也可以加粗，当然也可以加粗并强调。\n这里是二级标题  幸福的获得，在极大的程度上却是由于消除了对自我的过分关注。 \u0026mdash;Bertrand Arthur William Russell\n 你看，我还可以使用引用↑。\n关于 dash, en-dash 和 em-dash LaTeX 使用者都应该知道 dash, en-dash 和 em-dash。dash 是普通的连字符，举例如：「five-year-old boy」。en-dash 是表示范围的稍长的横线，举例如：「以下章节是重点：12\u0026ndash;15」。em-dash 则是英文中的破折号，举例如：「\u0026mdash;Bertrand Arthur William Russell」 \\end{markdown} \\end{document}\n\r\rmath \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\ronload=\u0026quot;renderMathInElement(document.body, {\r// customised options\rdelimiters: [\r{left: '$$', right: '$$', display: true}, // 独立一行显示\r{left: '$', right: '$', display: false}\t// 行内显示\r]\r});\u0026quot;\u0026gt;\r\u0026lt;/script\u0026gt;\r数学数列 $ E=mc^2 $： $$ F＝(1, 1, 2, 3, 5, 8, .","tags":null,"title":"test"},{"categories":null,"contents":"c\u0026#43;\u0026#43; 协程 C++ coroutines: The mental model for coroutine promises    doxygen 使用 mermaid  /*! \\~english * ... text ... * The distance between \\f$(x_1,y_1)\\f$ and \\f$(x_2,y_2)\\f$ is \\f$\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\f$. * @htmlonly * \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; * sequenceDiagram * Alice-\u0026gt;\u0026gt;John: Hello John, how are you? * loop Healthcheck * John-\u0026gt;\u0026gt;John: Fight against hypochondria * end * Note right of John: Rational thoughts! * John--\u0026gt;\u0026gt;Alice: Great! * John-\u0026gt;\u0026gt;Bob: How about you? * Bob--\u0026gt;\u0026gt;John: Jolly good! * \u0026lt;/div\u0026gt; * \u0026lt;script src=\u0026#34;https://unpkg.com/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; * \u0026lt;script\u0026gt;mermaid.initialize({startOnLoad:true});\u0026lt;/script\u0026gt; * @endhtmlonly */     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://gqw.gitee.io/notes/notes/","summary":"c\u0026#43;\u0026#43; 协程 C++ coroutines: The mental model for coroutine promises    doxygen 使用 mermaid  /*! \\~english * ... text ... * The distance between \\f$(x_1,y_1)\\f$ and \\f$(x_2,y_2)\\f$ is \\f$\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\f$. * @htmlonly * \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; * sequenceDiagram * Alice-\u0026gt;\u0026gt;John: Hello John, how are you? * loop Healthcheck * John-\u0026gt;\u0026gt;John: Fight against hypochondria * end * Note right of John: Rational thoughts! * John--\u0026gt;\u0026gt;Alice: Great! * John-\u0026gt;\u0026gt;Bob: How about you?","tags":null,"title":"随手记"}]